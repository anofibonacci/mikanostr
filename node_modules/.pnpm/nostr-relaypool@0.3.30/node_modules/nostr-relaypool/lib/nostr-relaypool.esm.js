// relay-pool.ts
import { getEventHash } from "nostr-tools";

// merge-similar-filters.ts
import { stringify } from "safe-stable-stringify";
function indexForFilter(filter, key) {
  let new_filter = { ...filter };
  delete new_filter[key];
  return key + stringify(new_filter);
}
function mergeSimilarAndRemoveEmptyFilters(filters) {
  let r = [];
  let indexByFilter = /* @__PURE__ */ new Map();
  for (let filter of filters) {
    let added = false;
    for (let key in filter) {
      if (filter[key] && (["ids", "authors", "kinds"].includes(key) || key.startsWith("#"))) {
        if (filter[key].length === 0) {
          added = true;
          break;
        }
        let index_by = indexForFilter(filter, key);
        let index = indexByFilter.get(index_by);
        if (index !== void 0) {
          let extendedFilter = r[index];
          for (let key2 in extendedFilter) {
            if (key2 !== key) {
              let index_by2 = indexForFilter(extendedFilter, key2);
              indexByFilter.delete(index_by2);
            }
          }
          r[index][key] = [...new Set(r[index][key].concat(filter[key]))];
          added = true;
          break;
        }
      }
    }
    if (!added) {
      for (let key in filter) {
        if (filter[key] && (["ids", "authors", "kinds"].includes(key) || key.startsWith("#"))) {
          let index_by = indexForFilter(filter, key);
          indexByFilter.set(index_by, r.length);
        }
      }
      r.push(filter);
    }
  }
  return r;
}

// relay.ts
import { verifySignature, validateEvent } from "nostr-tools";
import { matchFilters } from "nostr-tools";
import WebSocket from "isomorphic-ws";

// fakejson.ts
function getHex64(json, field) {
  let len = field.length + 3;
  let idx = json.indexOf(`"${field}":`) + len;
  let s = json.slice(idx).indexOf(`"`) + idx + 1;
  return json.slice(s, s + 64);
}
function getSubName(json) {
  let idx = json.indexOf(`"EVENT"`) + 7;
  let sliced = json.slice(idx);
  let idx2 = sliced.indexOf(`"`) + 1;
  let sliced2 = sliced.slice(idx2);
  return sliced2.slice(0, sliced2.indexOf(`"`));
}

// relay.ts
function relayInit(url, alreadyHaveEvent, dontAutoReconnect) {
  return new RelayC(url, alreadyHaveEvent, dontAutoReconnect).relayInit();
}
var RelayC = class {
  url;
  alreadyHaveEvent;
  constructor(url, alreadyHaveEvent, dontAutoReconnect) {
    this.url = url;
    this.alreadyHaveEvent = alreadyHaveEvent;
    this.dontAutoReconnect = dontAutoReconnect;
  }
  dontAutoReconnect;
  ws;
  sendOnConnect = [];
  openSubs = {};
  closedByClient = false;
  listeners = {
    connect: [],
    disconnect: [],
    error: [],
    notice: []
  };
  subListeners = {};
  pubListeners = {};
  incomingMessageQueue = [];
  handleNextInterval;
  #handleNext() {
    if (this.incomingMessageQueue.length === 0) {
      clearInterval(this.handleNextInterval);
      this.handleNextInterval = null;
      return;
    }
    this.#handleMessage({ data: this.incomingMessageQueue.shift() });
  }
  async trySend(params) {
    const msg = JSON.stringify(params);
    if (this.connected) {
      this.ws?.send(msg);
    } else {
      this.sendOnConnect.push(msg);
    }
  }
  resolveClose = void 0;
  async #onclose() {
    if (this.closedByClient) {
      this.listeners.disconnect.forEach((cb) => cb());
      this.resolveClose && this.resolveClose();
    } else {
      if (!this.dontAutoReconnect) {
        this.#reconnect();
      }
    }
  }
  reconnectTimeout = 0;
  #reconnect() {
    setTimeout(() => {
      this.reconnectTimeout = Math.max(2e3, this.reconnectTimeout * 2);
      this.connect();
    }, this.reconnectTimeout);
  }
  async #onmessage(e) {
    this.incomingMessageQueue.push(e.data);
    if (!this.handleNextInterval) {
      this.handleNextInterval = setInterval(() => this.#handleNext(), 0);
    }
  }
  async #handleMessage(e) {
    let data;
    let json = e.data.toString();
    if (!json) {
      return;
    }
    let event = this.alreadyHaveEvent && this.alreadyHaveEvent(getHex64(json, "id"));
    if (event) {
      return this.subListeners[getSubName(json)].event.forEach(
        (cb) => cb(event)
      );
    }
    try {
      data = JSON.parse(json);
    } catch (err) {
      data = e.data;
    }
    if (data.length >= 1) {
      switch (data[0]) {
        case "EVENT":
          if (data.length !== 3)
            return;
          const id = data[1];
          const event2 = data[2];
          if (validateEvent(event2) && this.openSubs[id] && (this.openSubs[id].skipVerification || verifySignature(event2)) && matchFilters(this.openSubs[id].filters, event2)) {
            this.openSubs[id];
            (this.subListeners[id]?.event || []).forEach((cb) => cb(event2));
          }
          return;
        case "EOSE": {
          if (data.length !== 2)
            return;
          const id2 = data[1];
          (this.subListeners[id2]?.eose || []).forEach((cb) => cb());
          return;
        }
        case "OK": {
          if (data.length < 3)
            return;
          const id2 = data[1];
          const ok = data[2];
          const reason = data[3] || "";
          if (ok)
            this.pubListeners[id2]?.ok.forEach((cb) => cb());
          else
            this.pubListeners[id2]?.failed.forEach((cb) => cb(reason));
          return;
        }
        case "NOTICE":
          if (data.length !== 2)
            return;
          const notice = data[1];
          this.listeners.notice.forEach((cb) => cb(notice));
          return;
      }
    }
  }
  #onopen(opened) {
    if (this.resolveClose) {
      this.resolveClose();
      return;
    }
    this.reconnectTimeout = 0;
    for (const subid in this.openSubs) {
      this.trySend(["REQ", subid, ...this.openSubs[subid].filters]);
    }
    for (const msg of this.sendOnConnect) {
      this.ws?.send(msg);
    }
    this.sendOnConnect = [];
    this.listeners.connect.forEach((cb) => cb());
    opened();
  }
  async connectRelay() {
    return new Promise((resolve, reject) => {
      const ws = new WebSocket(this.url);
      this.ws = ws;
      ws.onopen = this.#onopen.bind(this, resolve);
      ws.onerror = () => {
        this.listeners.error.forEach((cb) => cb());
        reject();
      };
      ws.onclose = this.#onclose.bind(this);
      ws.onmessage = this.#onmessage.bind(this);
    });
  }
  async connect() {
    if (this.ws?.readyState && this.ws.readyState === 1)
      return;
    await this.connectRelay();
  }
  relayInit() {
    const this2 = this;
    return {
      url: this2.url,
      sub: this2.sub.bind(this2),
      on: this2.on.bind(this2),
      off: this2.off.bind(this2),
      publish: this2.publish.bind(this2),
      connect: this2.connect.bind(this2),
      close() {
        return this2.close();
      },
      get status() {
        return this2.status;
      }
    };
  }
  get status() {
    return this.ws?.readyState ?? 3;
  }
  get connected() {
    return this.ws?.readyState === 1;
  }
  close() {
    this.closedByClient = true;
    if (this.connected) {
      this.ws?.close();
    }
    return new Promise((resolve) => {
      this.resolveClose = resolve;
    });
  }
  on(type, cb) {
    this.listeners[type].push(cb);
    if (type === "connect" && this.ws?.readyState === 1) {
      cb();
    }
  }
  off(type, cb) {
    const index = this.listeners[type].indexOf(cb);
    if (index !== -1)
      this.listeners[type].splice(index, 1);
  }
  publish(event) {
    const this2 = this;
    if (!event.id)
      throw new Error(`event ${event} has no id`);
    const id = event.id;
    let sent = false;
    let mustMonitor = false;
    this2.trySend(["EVENT", event]).then(() => {
      sent = true;
      if (mustMonitor) {
        startMonitoring();
        mustMonitor = false;
      }
    }).catch(() => {
    });
    const startMonitoring = () => {
      const monitor = this.sub([{ ids: [id] }], {
        id: `monitor-${id.slice(0, 5)}`
      });
      const willUnsub = setTimeout(() => {
        (this2.pubListeners[id]?.failed || []).forEach(
          (cb) => cb("event not seen after 5 seconds")
        );
        monitor.unsub();
      }, 5e3);
      monitor.on("event", () => {
        clearTimeout(willUnsub);
        (this2.pubListeners[id]?.seen || []).forEach((cb) => cb());
      });
    };
    return {
      on: (type, cb) => {
        this2.pubListeners[id] = this2.pubListeners[id] || {
          ok: [],
          seen: [],
          failed: []
        };
        this2.pubListeners[id][type].push(cb);
        if (type === "seen") {
          if (sent)
            startMonitoring();
          else
            mustMonitor = true;
        }
      },
      off: (type, cb) => {
        const listeners = this2.pubListeners[id];
        if (!listeners)
          return;
        const idx = listeners[type].indexOf(cb);
        if (idx >= 0)
          listeners[type].splice(idx, 1);
      }
    };
  }
  sub(filters, opts = {}) {
    const this2 = this;
    const subid = opts.id || Math.random().toString().slice(2);
    const skipVerification = opts.skipVerification || false;
    this2.openSubs[subid] = {
      id: subid,
      filters,
      skipVerification
    };
    if (this2.connected) {
      this2.trySend(["REQ", subid, ...filters]);
    }
    return {
      sub: (newFilters, newOpts = {}) => this.sub(newFilters || filters, {
        skipVerification: newOpts.skipVerification || skipVerification,
        id: subid
      }),
      unsub: () => {
        delete this2.openSubs[subid];
        delete this2.subListeners[subid];
        if (this2.connected) {
          this2.trySend(["CLOSE", subid]);
        }
      },
      on: (type, cb) => {
        this2.subListeners[subid] = this2.subListeners[subid] || {
          event: [],
          eose: []
        };
        this2.subListeners[subid][type].push(cb);
      },
      off: (type, cb) => {
        const listeners = this2.subListeners[subid];
        const idx = listeners[type].indexOf(cb);
        if (idx >= 0)
          listeners[type].splice(idx, 1);
      }
    };
  }
};

// event-cache.ts
import { Kind } from "nostr-tools";
var EventCache = class {
  eventsById = /* @__PURE__ */ new Map();
  metadataByPubKey = /* @__PURE__ */ new Map();
  contactsByPubKey = /* @__PURE__ */ new Map();
  addEvent(event) {
    this.eventsById.set(event.id, event);
    if (event.kind === Kind.Metadata) {
      this.metadataByPubKey.set(event.pubkey, event);
    }
    if (event.kind === Kind.Contacts) {
      this.contactsByPubKey.set(event.pubkey, event);
    }
  }
  getEventById(id) {
    return this.eventsById.get(id);
  }
  hasEventById(id) {
    return this.eventsById.has(id);
  }
  #getCachedEventsByPubKeyWithUpdatedFilter(filter) {
    if (filter.noCache || !filter.authors || !filter.kinds || filter.kinds.find(
      (kind) => kind !== Kind.Contacts && kind !== Kind.Metadata
    ) !== void 0) {
      return void 0;
    }
    const authors = [];
    const events = /* @__PURE__ */ new Set();
    for (const author of filter.authors) {
      let contactEvent;
      if (filter.kinds.includes(Kind.Contacts)) {
        contactEvent = this.contactsByPubKey.get(author);
        if (!contactEvent) {
          authors.push(author);
          continue;
        }
      }
      let metadataEvent;
      if (filter.kinds.includes(Kind.Metadata)) {
        metadataEvent = this.metadataByPubKey.get(author);
        if (!metadataEvent) {
          authors.push(author);
          continue;
        }
      }
      if (contactEvent) {
        events.add(contactEvent);
      }
      if (metadataEvent) {
        events.add(metadataEvent);
      }
    }
    return { filter: { ...filter, authors }, events };
  }
  #getCachedEventsByIdWithUpdatedFilter(filter) {
    if (!filter.ids) {
      return void 0;
    }
    const events = /* @__PURE__ */ new Set();
    const ids = [];
    for (const id of filter.ids) {
      const event = this.getEventById(id);
      if (event) {
        events.add(event);
      } else {
        ids.push(id);
      }
    }
    return { filter: { ...filter, ids }, events };
  }
  getCachedEventsWithUpdatedFilters(filters, relays) {
    const events = /* @__PURE__ */ new Set();
    const new_filters = [];
    for (const filter of filters) {
      const new_data = this.#getCachedEventsByIdWithUpdatedFilter(filter) || this.#getCachedEventsByPubKeyWithUpdatedFilter(filter) || {
        filter,
        events: []
      };
      for (const event of new_data.events) {
        events.add(event);
      }
      new_filters.push(new_data.filter);
    }
    return { filters: new_filters, events: [...events] };
  }
};

// author.ts
import { Kind as Kind2 } from "nostr-tools";
var Author = class {
  pubkey;
  relayPool;
  relays;
  constructor(relayPool, relays, pubkey) {
    this.pubkey = pubkey;
    this.relayPool = relayPool;
    this.relays = relays;
  }
  metaData(cb, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          authors: [this.pubkey],
          kinds: [Kind2.Metadata]
        }
      ],
      this.relays,
      cb,
      maxDelayms
    );
  }
  subscribe(filters, cb, maxDelayms) {
    return this.relayPool.subscribe(
      filters.map((filter) => ({
        authors: [this.pubkey],
        ...filter
      })),
      this.relays,
      cb,
      maxDelayms
    );
  }
  followsPubkeys(cb, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          authors: [this.pubkey],
          kinds: [Kind2.Contacts]
        }
      ],
      this.relays,
      (event) => {
        let r = [];
        for (const tag of event.tags) {
          if (tag[0] === "p") {
            r.push(tag[1]);
          }
        }
        cb(r);
      },
      maxDelayms
    );
  }
  follows(cb, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          authors: [this.pubkey],
          kinds: [Kind2.Contacts]
        }
      ],
      this.relays,
      (event) => {
        let r = [];
        for (const tag of event.tags) {
          if (tag[0] === "p") {
            let relays = this.relays;
            if (tag[1]) {
              relays = [tag[1], ...this.relays];
            }
            r.push(new Author(this.relayPool, relays, tag[1]));
          }
        }
        cb(r);
      },
      maxDelayms
    );
  }
  secondFollows(cb, maxDelayms, removeDirectFollows = true) {
    return this.followsPubkeys((pubkeys) => {
      let sfollows = /* @__PURE__ */ new Map();
      for (const pubkey of pubkeys) {
        this.relayPool.subscribe(
          [
            {
              authors: [pubkey],
              kinds: [Kind2.Contacts]
            }
          ],
          this.relays,
          (event) => {
            let dweight = 1 / event.tags.length;
            for (const tag of event.tags) {
              if (tag[0] === "p") {
                let weight = sfollows.get(tag[1]);
                if (weight) {
                  weight += dweight;
                } else {
                  weight = dweight;
                }
                sfollows.set(tag[1], weight);
              }
            }
            if (removeDirectFollows) {
              for (const pubkey2 of pubkeys) {
                sfollows.delete(pubkey2);
              }
            }
            cb(Array.from(sfollows.entries()).sort((a, b) => b[1] - a[1]));
          },
          maxDelayms
        );
      }
    }, maxDelayms);
  }
  allEvents(cb, limit = 100, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          authors: [this.pubkey],
          limit
        }
      ],
      this.relays,
      cb,
      maxDelayms
    );
  }
  referenced(cb, limit = 100, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          "#p": [this.pubkey],
          limit
        }
      ],
      this.relays,
      cb,
      maxDelayms
    );
  }
  followers(cb, limit = 100, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          "#p": [this.pubkey],
          kinds: [Kind2.Contacts],
          limit
        }
      ],
      this.relays,
      cb,
      maxDelayms
    );
  }
  sentAndRecievedDMs(cb, limit = 100, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          authors: [this.pubkey],
          kinds: [Kind2.EncryptedDirectMessage],
          limit
        },
        {
          "#p": [this.pubkey],
          kinds: [Kind2.EncryptedDirectMessage],
          limit
        }
      ],
      this.relays,
      cb,
      maxDelayms
    );
  }
  text(cb, limit = 100, maxDelayms) {
    return this.relayPool.subscribe(
      [
        {
          authors: [this.pubkey],
          kinds: [Kind2.Text],
          limit
        }
      ],
      this.relays,
      cb,
      maxDelayms
    );
  }
};

// event.ts
var Event = class {
  id;
  kind;
  pubkey;
  tags;
  created_at;
  content;
  relayPool;
  relays;
  constructor(event, relayPool, relays) {
    this.id = event.id;
    this.kind = event.kind;
    this.pubkey = event.pubkey;
    this.tags = event.tags;
    this.created_at = event.created_at;
    this.content = event.content;
    this.relayPool = relayPool;
    this.relays = relays;
  }
  referencedAuthors() {
    const r = [];
    for (const tag of this.tags) {
      if (tag[0] === "p") {
        r.push(new Author(this.relayPool, this.relays, tag[1]));
      }
    }
    return r;
  }
  referencedEvents(maxDelayms) {
    const r = [];
    for (const tag of this.tags) {
      if (tag[0] === "e") {
        let relays = this.relays;
        if (tag[2]) {
          relays = [tag[2], ...relays];
        }
        r.push(
          this.relayPool.getEventById(tag[1], relays, maxDelayms).then((e) => new Event(e, this.relayPool, this.relays))
        );
      }
    }
    return r;
  }
  thread(cb, maxDelayms) {
    let relays = this.relays;
    let ids = [];
    for (const tag of this.tags) {
      if (tag[0] === "e") {
        if (tag[2]) {
          relays = [tag[2], ...relays];
        }
        ids.push(tag[1]);
      }
    }
    return this.relayPool.subscribe(
      [{ ids }, { "#e": ids }],
      relays,
      cb,
      maxDelayms
    );
  }
};

// on-event-filters.ts
import { Kind as Kind3, matchFilter } from "nostr-tools";
function doNotEmitDuplicateEvents(onEvent) {
  let event_ids = /* @__PURE__ */ new Set();
  return (event, afterEose, url) => {
    if (event_ids.has(event.id))
      return;
    event_ids.add(event.id);
    onEvent(event, afterEose, url);
  };
}
function doNotEmitOlderEvents(onEvent) {
  let created_at_by_events_kinds = /* @__PURE__ */ new Map();
  return (event, afterEose, url) => {
    if (event.kind === Kind3.Metadata || event.kind === Kind3.Contacts) {
      let event_kind = event.pubkey + " " + event.kind;
      if ((created_at_by_events_kinds.get(event_kind) || 0) > event.created_at)
        return;
      created_at_by_events_kinds.set(event_kind, event.created_at);
    }
    onEvent(event, afterEose, url);
  };
}
function matchOnEventFilters(onEvent, filters) {
  return (event, afterEose, url) => {
    for (let filter of filters) {
      if (matchFilter(filter, event)) {
        onEvent(event, afterEose, url);
        break;
      }
    }
  };
}
function emitEventsOnNextTick(onEvent) {
  return (event, afterEose, url) => {
    setTimeout(() => {
      onEvent(event, afterEose, url);
    }, 0);
  };
}

// group-filters-by-relay.ts
var unique = (arr) => [...new Set(arr)];
function groupFiltersByRelayAndEmitCacheHits(filters, relays, onEvent, options = {}, eventCache) {
  let events = [];
  if (eventCache) {
    const cachedEventsWithUpdatedFilters = eventCache.getCachedEventsWithUpdatedFilters(filters, relays);
    filters = cachedEventsWithUpdatedFilters.filters;
    events = cachedEventsWithUpdatedFilters.events;
  }
  if (!options.allowDuplicateEvents) {
    onEvent = doNotEmitDuplicateEvents(onEvent);
  }
  if (!options.allowOlderEvents) {
    onEvent = doNotEmitOlderEvents(onEvent);
  }
  for (const event of events) {
    onEvent(event, false, void 0);
  }
  filters = mergeSimilarAndRemoveEmptyFilters(filters);
  onEvent = matchOnEventFilters(onEvent, filters);
  relays = unique(relays);
  const filtersByRelay = getFiltersByRelay(filters, relays);
  return [onEvent, filtersByRelay];
}
function getFiltersByRelay(filters, relays) {
  const filtersByRelay = /* @__PURE__ */ new Map();
  const filtersWithoutRelay = [];
  for (const filter of filters) {
    const relay = filter.relay;
    if (relay) {
      const relayFilters = filtersByRelay.get(relay);
      if (relayFilters) {
        relayFilters.push(withoutRelay(filter));
      } else {
        filtersByRelay.set(relay, [withoutRelay(filter)]);
      }
    } else {
      filtersWithoutRelay.push(filter);
    }
  }
  if (filtersWithoutRelay.length > 0) {
    for (const relay of relays) {
      const filters2 = filtersByRelay.get(relay);
      if (filters2) {
        filtersByRelay.set(relay, filters2.concat(filtersWithoutRelay));
      } else {
        filtersByRelay.set(relay, filtersWithoutRelay);
      }
    }
  }
  return filtersByRelay;
}
function withoutRelay(filter) {
  filter = { ...filter };
  delete filter.relay;
  return filter;
}
function batchFiltersByRelay(subscribedFilters) {
  const filtersByRelay = /* @__PURE__ */ new Map();
  const onEvents = [];
  for (const [onEvent2, filtersByRelayBySub] of subscribedFilters) {
    for (const [relay, filters] of filtersByRelayBySub) {
      const filtersByRelayFilters = filtersByRelay.get(relay);
      if (filtersByRelayFilters) {
        filtersByRelay.set(relay, filtersByRelayFilters.concat(filters));
      } else {
        filtersByRelay.set(relay, filters);
      }
    }
    onEvents.push(onEvent2);
  }
  const onEvent = (event, afterEose, url) => {
    for (const onEvent2 of onEvents) {
      onEvent2(event, afterEose, url);
    }
  };
  return [onEvent, filtersByRelay];
}

// relay-pool.ts
var unique2 = (arr) => [...new Set(arr)];
var RelayPool = class {
  relayByUrl = /* @__PURE__ */ new Map();
  noticecbs = [];
  eventCache;
  minMaxDelayms = Infinity;
  filtersToSubscribe = [];
  timer;
  externalGetEventById;
  dontLogSubscriptions = false;
  dontAutoReconnect = false;
  constructor(relays, options = {}) {
    this.externalGetEventById = options.externalGetEventById;
    this.dontLogSubscriptions = options.dontLogSubscriptions;
    this.dontAutoReconnect = options.dontAutoReconnect;
    if (!options.noCache) {
      this.eventCache = new EventCache();
    }
    if (relays) {
      for (const relay of unique2(relays)) {
        this.addOrGetRelay(relay);
      }
    }
  }
  addOrGetRelay(relay) {
    const origRelayInstance = this.relayByUrl.get(relay);
    if (origRelayInstance) {
      return origRelayInstance;
    }
    const relayInstance = relayInit(
      relay,
      this.externalGetEventById ? this.externalGetEventById : this.eventCache ? (id) => this.eventCache?.getEventById(id) : void 0,
      this.dontAutoReconnect
    );
    this.relayByUrl.set(relay, relayInstance);
    relayInstance.connect().then(
      (onfulfilled) => {
        relayInstance?.on("notice", (relay2, msg) => {
          this.noticecbs.forEach((cb) => cb(relay2, msg));
        });
      },
      (onrejected) => {
        console.warn("failed to connect to relay " + relay);
      }
    );
    return relayInstance;
  }
  async close() {
    const promises = [];
    for (const relayInstance of this.relayByUrl.values()) {
      promises.push(relayInstance.close());
    }
    this.relayByUrl.clear();
    return Promise.all(promises);
  }
  #subscribeRelay(relay, filters, onEvent, onEose) {
    const mergedAndRemovedEmptyFilters = mergeSimilarAndRemoveEmptyFilters(filters);
    if (mergedAndRemovedEmptyFilters.length === 0) {
      return;
    }
    const instance = this.addOrGetRelay(relay);
    const sub = instance.sub(mergedAndRemovedEmptyFilters);
    let eventsBySub = [];
    sub.on("event", (nostrEvent) => {
      let event = new Event(
        nostrEvent,
        this,
        Array.from(this.relayByUrl.keys())
      );
      this.eventCache?.addEvent(event);
      eventsBySub?.push(event);
      onEvent(event, eventsBySub === void 0, relay);
    });
    if (onEose) {
      sub.on("eose", () => {
        onEose(eventsBySub, relay);
        eventsBySub = void 0;
      });
    }
    return sub;
  }
  #subscribeRelays(filtersByRelay, onEvent, onEose) {
    if (filtersByRelay.size === 0) {
      return () => {
      };
    }
    if (!this.dontLogSubscriptions) {
      console.log("RelayPool subscribing to relays", filtersByRelay);
    }
    const subs = [];
    for (const [relay, filters] of filtersByRelay) {
      const sub = this.#subscribeRelay(relay, filters, onEvent, onEose);
      if (sub) {
        subs.push(sub);
      }
    }
    return () => subs.forEach((sub) => sub.unsub());
  }
  sendSubscriptions(onEose) {
    clearTimeout(this.timer);
    this.timer = void 0;
    this.minMaxDelayms = Infinity;
    const [onEvent, filtersByRelay] = batchFiltersByRelay(this.filtersToSubscribe);
    this.filtersToSubscribe = [];
    return this.#subscribeRelays(filtersByRelay, onEvent, onEose);
  }
  #resetTimer(maxDelayms) {
    if (this.minMaxDelayms > maxDelayms) {
      this.minMaxDelayms = maxDelayms;
    }
    clearTimeout(this.timer);
    this.timer = void 0;
    if (this.minMaxDelayms !== Infinity) {
      this.timer = setTimeout(() => {
        this.sendSubscriptions();
      }, this.minMaxDelayms);
    }
  }
  subscribe(filters, relays, onEvent, maxDelayms, onEose, options = {}) {
    if (maxDelayms && onEose) {
      throw new Error("maxDelayms and onEose cannot be used together");
    }
    const [dedupedOnEvent, filtersByRelay] = groupFiltersByRelayAndEmitCacheHits(
      filters,
      relays,
      onEvent,
      options,
      this.eventCache
    );
    this.filtersToSubscribe.push([dedupedOnEvent, filtersByRelay]);
    if (maxDelayms) {
      this.#resetTimer(maxDelayms);
      return () => {
      };
    }
    return this.sendSubscriptions(onEose);
  }
  async getEventById(id, relays, maxDelayms) {
    return new Promise((resolve, reject) => {
      this.subscribe(
        [{ ids: [id] }],
        relays,
        (event) => {
          resolve(event);
        },
        maxDelayms
      );
    });
  }
  publish(event, relays) {
    const eventWithId = { ...event, id: getEventHash(event) };
    for (const relay of unique2(relays)) {
      const instance = this.addOrGetRelay(relay);
      instance.publish(eventWithId);
    }
  }
  onnotice(cb) {
    this.noticecbs.push(cb);
  }
  onerror(cb) {
    this.relayByUrl.forEach(
      (relay, url) => relay.on("error", (msg) => cb(url, msg))
    );
  }
  ondisconnect(cb) {
    this.relayByUrl.forEach(
      (relay, url) => relay.on("disconnect", (msg) => cb(url, msg))
    );
  }
  getRelayStatuses() {
    return Array.from(this.relayByUrl.entries()).map(
      ([url, relay]) => [url, relay.status]
    ).sort();
  }
};

// collect.ts
var binarySearch = function(a, target) {
  var l = 0, h = a.length - 1, m, comparison;
  let comparator = function(a2, b) {
    return a2.created_at - b.created_at;
  };
  while (l <= h) {
    m = l + h >>> 1;
    comparison = comparator(a[m], target);
    if (comparison < 0) {
      l = m + 1;
    } else if (comparison > 0) {
      h = m - 1;
    } else {
      return m;
    }
  }
  return ~l;
};
var binaryInsert = function(a, target) {
  const duplicate = true;
  var i = binarySearch(a, target);
  if (i >= 0) {
    if (!duplicate) {
      return i;
    }
  } else {
    i = ~i;
  }
  a.splice(i, 0, target);
  return i;
};
function collect(onEvents, skipSort = false) {
  let events = [];
  return (event, afterEose, url) => {
    if (skipSort) {
      events.push(event);
    } else {
      binaryInsert(events, event);
    }
    onEvents(events);
  };
}
export {
  Author,
  RelayPool,
  collect,
  emitEventsOnNextTick
};
