{
  "version": 3,
  "sources": ["../relay-pool.ts", "../merge-similar-filters.ts", "../relay.ts", "../fakejson.ts", "../event-cache.ts", "../author.ts", "../event.ts", "../on-event-filters.ts", "../group-filters-by-relay.ts", "../collect.ts"],
  "sourcesContent": ["import {Filter, getEventHash, Sub} from \"nostr-tools\";\nimport {mergeSimilarAndRemoveEmptyFilters} from \"./merge-similar-filters\";\nimport {type Relay, relayInit} from \"./relay\";\nimport {type OnEvent} from \"./on-event-filters\";\nimport {EventCache} from \"./event-cache\";\nimport {Event, NostrToolsEvent, NostrToolsEventWithId} from \"./event\";\nimport {\n  batchFiltersByRelay,\n  groupFiltersByRelayAndEmitCacheHits,\n} from \"./group-filters-by-relay\";\n\nconst unique = (arr: string[]) => [...new Set(arr)];\n\nexport {type OnEvent} from \"./on-event-filters\";\nexport type OnEose = (\n  eventsByThisSub: Event[] | undefined,\n  url: string\n) => void;\n\nexport class RelayPool {\n  relayByUrl: Map<string, Relay> = new Map();\n  noticecbs: Array<(url: string, msg: string) => void> = [];\n  eventCache?: EventCache;\n  minMaxDelayms: number = Infinity;\n  filtersToSubscribe: [OnEvent, Map<string, Filter[]>][] = [];\n  timer?: ReturnType<typeof setTimeout>;\n  externalGetEventById?: (id: string) => NostrToolsEventWithId | undefined;\n  dontLogSubscriptions?: boolean = false;\n  dontAutoReconnect?: boolean = false;\n\n  constructor(\n    relays?: string[],\n    options: {\n      noCache?: boolean;\n      externalGetEventById?: (id: string) => NostrToolsEventWithId | undefined;\n      dontLogSubscriptions?: boolean;\n      dontAutoReconnect?: boolean;\n    } = {}\n  ) {\n    this.externalGetEventById = options.externalGetEventById;\n    this.dontLogSubscriptions = options.dontLogSubscriptions;\n    this.dontAutoReconnect = options.dontAutoReconnect;\n    if (!options.noCache) {\n      this.eventCache = new EventCache();\n    }\n    if (relays) {\n      for (const relay of unique(relays)) {\n        this.addOrGetRelay(relay);\n      }\n    }\n  }\n\n  addOrGetRelay(relay: string): Relay {\n    const origRelayInstance = this.relayByUrl.get(relay);\n    if (origRelayInstance) {\n      return origRelayInstance;\n    }\n    const relayInstance = relayInit(\n      relay,\n      this.externalGetEventById\n        ? this.externalGetEventById\n        : this.eventCache\n        ? (id) => this.eventCache?.getEventById(id)\n        : undefined,\n      this.dontAutoReconnect\n    );\n    this.relayByUrl.set(relay, relayInstance);\n    relayInstance.connect().then(\n      (onfulfilled) => {\n        relayInstance?.on(\"notice\", (relay: string, msg: string) => {\n          this.noticecbs.forEach((cb) => cb(relay, msg));\n        });\n      },\n      (onrejected) => {\n        console.warn(\"failed to connect to relay \" + relay);\n      }\n    );\n    return relayInstance;\n  }\n\n  async close() {\n    const promises = [];\n    for (const relayInstance of this.relayByUrl.values()) {\n      promises.push(relayInstance.close());\n    }\n    this.relayByUrl.clear();\n    return Promise.all(promises);\n  }\n\n  #subscribeRelay(\n    relay: string,\n    filters: Filter[],\n    onEvent: OnEvent,\n    onEose?: OnEose\n  ): Sub | undefined {\n    const mergedAndRemovedEmptyFilters =\n      mergeSimilarAndRemoveEmptyFilters(filters);\n    if (mergedAndRemovedEmptyFilters.length === 0) {\n      return;\n    }\n    const instance = this.addOrGetRelay(relay);\n    const sub = instance.sub(mergedAndRemovedEmptyFilters);\n    let eventsBySub: Event[] | undefined = [];\n    sub.on(\"event\", (nostrEvent: NostrToolsEventWithId) => {\n      let event = new Event(\n        nostrEvent,\n        this,\n        Array.from(this.relayByUrl.keys())\n      );\n      this.eventCache?.addEvent(event);\n      eventsBySub?.push(event);\n      onEvent(event, eventsBySub === undefined, relay);\n    });\n    if (onEose) {\n      sub.on(\"eose\", () => {\n        onEose(eventsBySub, relay);\n        eventsBySub = undefined;\n      });\n    }\n    return sub;\n  }\n\n  #subscribeRelays(\n    filtersByRelay: Map<string, Filter[]>,\n    onEvent: OnEvent,\n    onEose?: OnEose\n  ): () => void {\n    if (filtersByRelay.size === 0) {\n      return () => {};\n    }\n    if (!this.dontLogSubscriptions) {\n      console.log(\"RelayPool subscribing to relays\", filtersByRelay);\n    }\n    const subs: Sub[] = [];\n    for (const [relay, filters] of filtersByRelay) {\n      const sub = this.#subscribeRelay(relay, filters, onEvent, onEose);\n      if (sub) {\n        subs.push(sub);\n      }\n    }\n    return () => subs.forEach((sub) => sub.unsub());\n  }\n\n  sendSubscriptions(onEose?: OnEose) {\n    clearTimeout(this.timer);\n    this.timer = undefined;\n    this.minMaxDelayms = Infinity;\n\n    const [onEvent, filtersByRelay]: [OnEvent, Map<string, Filter[]>] =\n      batchFiltersByRelay(this.filtersToSubscribe);\n    this.filtersToSubscribe = [];\n\n    return this.#subscribeRelays(filtersByRelay, onEvent, onEose);\n  }\n\n  #resetTimer(maxDelayms: number) {\n    if (this.minMaxDelayms > maxDelayms) {\n      this.minMaxDelayms = maxDelayms;\n    }\n\n    clearTimeout(this.timer);\n    this.timer = undefined;\n\n    if (this.minMaxDelayms !== Infinity) {\n      this.timer = setTimeout(() => {\n        this.sendSubscriptions();\n      }, this.minMaxDelayms);\n    }\n  }\n\n  subscribe(\n    filters: (Filter & {relay?: string; noCache?: boolean})[],\n    relays: string[],\n    onEvent: OnEvent,\n    maxDelayms?: number,\n    onEose?: OnEose,\n    options: {allowDuplicateEvents?: boolean; allowOlderEvents?: boolean} = {}\n  ): () => void {\n    if (maxDelayms && onEose) {\n      throw new Error(\"maxDelayms and onEose cannot be used together\");\n    }\n    const [dedupedOnEvent, filtersByRelay] =\n      groupFiltersByRelayAndEmitCacheHits(\n        filters,\n        relays,\n        onEvent,\n        options,\n        this.eventCache\n      );\n    this.filtersToSubscribe.push([dedupedOnEvent, filtersByRelay]);\n    if (maxDelayms) {\n      this.#resetTimer(maxDelayms);\n      return () => {};\n    }\n    return this.sendSubscriptions(onEose);\n  }\n\n  async getEventById(\n    id: string,\n    relays: string[],\n    maxDelayms: number\n  ): Promise<Event> {\n    return new Promise((resolve, reject) => {\n      this.subscribe(\n        [{ids: [id]}],\n        relays,\n        (event) => {\n          resolve(event);\n        },\n        maxDelayms\n      );\n    });\n  }\n\n  publish(event: NostrToolsEvent, relays: string[]) {\n    const eventWithId = {...event, id: getEventHash(event)};\n    for (const relay of unique(relays)) {\n      const instance = this.addOrGetRelay(relay);\n      instance.publish(eventWithId);\n    }\n  }\n\n  onnotice(cb: (url: string, msg: string) => void) {\n    this.noticecbs.push(cb);\n  }\n\n  onerror(cb: (url: string, msg: string) => void) {\n    this.relayByUrl.forEach((relay: Relay, url: string) =>\n      relay.on(\"error\", (msg: string) => cb(url, msg))\n    );\n  }\n  ondisconnect(cb: (url: string, msg: string) => void) {\n    this.relayByUrl.forEach((relay: Relay, url: string) =>\n      relay.on(\"disconnect\", (msg: string) => cb(url, msg))\n    );\n  }\n  getRelayStatuses(): [url: string, staus: number][] {\n    return Array.from(this.relayByUrl.entries())\n      .map(\n        ([url, relay]: [string, Relay]) =>\n          [url, relay.status] as [string, number]\n      )\n      .sort();\n  }\n}\n", "import {stringify} from \"safe-stable-stringify\";\nimport type {Filter} from \"nostr-tools\";\n\nfunction indexForFilter(filter: Filter, key: string): string {\n  let new_filter = {...filter};\n  // @ts-ignore\n  delete new_filter[key];\n  return key + stringify(new_filter);\n}\n\nexport function mergeSimilarAndRemoveEmptyFilters(filters: Filter[]): Filter[] {\n  let r = [];\n  let indexByFilter = new Map<string, number>();\n  for (let filter of filters) {\n    let added = false;\n    for (let key in filter) {\n      if (\n        // @ts-ignore\n        filter[key] &&\n        ([\"ids\", \"authors\", \"kinds\"].includes(key) || key.startsWith(\"#\"))\n      ) {\n        // @ts-ignore\n        if (filter[key].length === 0) {\n          added = true;\n          break;\n        }\n        let index_by = indexForFilter(filter, key);\n        let index = indexByFilter.get(index_by);\n        if (index !== undefined) {\n          // @ts-ignore\n          let extendedFilter = r[index];\n          // remove all other groupings for r[index]\n          for (let key2 in extendedFilter) {\n            if (key2 !== key) {\n              let index_by2 = indexForFilter(extendedFilter, key2);\n              indexByFilter.delete(index_by2);\n            }\n          }\n          // @ts-ignore\n          r[index][key] = [...new Set(r[index][key].concat(filter[key]))];\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      for (let key in filter) {\n        if (\n          // @ts-ignore\n          filter[key] &&\n          ([\"ids\", \"authors\", \"kinds\"].includes(key) || key.startsWith(\"#\"))\n        ) {\n          let index_by = indexForFilter(filter, key);\n          indexByFilter.set(index_by, r.length);\n        }\n      }\n      r.push(filter);\n    }\n  }\n  return r;\n}\n", "// allows sub/unsub and publishing before connection is established.\n// Much more refactoring is needed\n// Don't rely on Relay interface, it will change (I'll probably delete a lot of code from here, there's no need for\n// multiple listeners)\n\nimport {type Event, verifySignature, validateEvent} from \"nostr-tools\";\nimport {type Filter, matchFilters} from \"nostr-tools\";\nimport WebSocket from \"isomorphic-ws\";\nimport {getHex64, getSubName} from \"./fakejson\";\n\ntype RelayEvent = \"connect\" | \"disconnect\" | \"error\" | \"notice\";\n\nexport type Relay = {\n  url: string;\n  status: number;\n  connect: () => Promise<void>;\n  close: () => Promise<void>;\n  sub: (filters: Filter[], opts?: SubscriptionOptions) => Sub;\n  publish: (event: Event) => Pub;\n  on: (type: RelayEvent, cb: any) => void;\n  off: (type: RelayEvent, cb: any) => void;\n};\nexport type Pub = {\n  on: (type: \"ok\" | \"seen\" | \"failed\", cb: any) => void;\n  off: (type: \"ok\" | \"seen\" | \"failed\", cb: any) => void;\n};\nexport type Sub = {\n  sub: (filters: Filter[], opts: SubscriptionOptions) => Sub;\n  unsub: () => void;\n  on: (type: \"event\" | \"eose\", cb: any) => void;\n  off: (type: \"event\" | \"eose\", cb: any) => void;\n};\n\ntype SubscriptionOptions = {\n  skipVerification?: boolean;\n  id?: string;\n};\nexport function relayInit(\n  url: string,\n  alreadyHaveEvent?: (id: string) => (Event & {id: string}) | undefined,\n  dontAutoReconnect?: boolean\n): Relay {\n  return new RelayC(url, alreadyHaveEvent, dontAutoReconnect).relayInit();\n}\nclass RelayC {\n  url: string;\n  alreadyHaveEvent?: (id: string) => (Event & {id: string}) | undefined;\n  constructor(\n    url: string,\n    alreadyHaveEvent?: (id: string) => (Event & {id: string}) | undefined,\n    dontAutoReconnect?: boolean\n  ) {\n    this.url = url;\n    this.alreadyHaveEvent = alreadyHaveEvent;\n    this.dontAutoReconnect = dontAutoReconnect;\n  }\n  dontAutoReconnect?: boolean;\n  ws: WebSocket | undefined;\n  sendOnConnect: string[] = [];\n  openSubs: {[id: string]: {filters: Filter[]} & SubscriptionOptions} = {};\n  closedByClient: boolean = false;\n  listeners: {\n    connect: Array<() => void>;\n    disconnect: Array<() => void>;\n    error: Array<() => void>;\n    notice: Array<(msg: string) => void>;\n  } = {\n    connect: [],\n    disconnect: [],\n    error: [],\n    notice: [],\n  };\n  subListeners: {\n    [subid: string]: {\n      event: Array<(event: Event) => void>;\n      eose: Array<() => void>;\n    };\n  } = {};\n  pubListeners: {\n    [eventid: string]: {\n      ok: Array<() => void>;\n      seen: Array<() => void>;\n      failed: Array<(reason: string) => void>;\n    };\n  } = {};\n  incomingMessageQueue: string[] = [];\n  handleNextInterval: any;\n\n  #handleNext() {\n    if (this.incomingMessageQueue.length === 0) {\n      clearInterval(this.handleNextInterval);\n      this.handleNextInterval = null;\n      return;\n    }\n    this.#handleMessage({data: this.incomingMessageQueue.shift()});\n  }\n\n  async trySend(params: [string, ...any]) {\n    const msg = JSON.stringify(params);\n\n    if (this.connected) {\n      this.ws?.send(msg);\n    } else {\n      this.sendOnConnect.push(msg);\n    }\n  }\n  resolveClose: (() => void) | undefined = undefined;\n\n  async #onclose() {\n    if (this.closedByClient) {\n      this.listeners.disconnect.forEach((cb) => cb());\n      this.resolveClose && this.resolveClose();\n    } else {\n      if (!this.dontAutoReconnect) {\n        this.#reconnect();\n      }\n    }\n  }\n  reconnectTimeout: number = 0;\n  #reconnect() {\n    setTimeout(() => {\n      this.reconnectTimeout = Math.max(2000, this.reconnectTimeout * 2);\n      this.connect();\n    }, this.reconnectTimeout);\n  }\n\n  async #onmessage(e: any) {\n    this.incomingMessageQueue.push(e.data);\n    if (!this.handleNextInterval) {\n      this.handleNextInterval = setInterval(() => this.#handleNext(), 0);\n    }\n  }\n\n  async #handleMessage(e: any) {\n    let data;\n    let json: string = e.data.toString();\n    if (!json) {\n      return;\n    }\n    let event =\n      this.alreadyHaveEvent && this.alreadyHaveEvent(getHex64(json, \"id\"));\n    if (event) {\n      return this.subListeners[getSubName(json)].event.forEach((cb) =>\n        // @ts-ignore\n        cb(event)\n      );\n    }\n    try {\n      data = JSON.parse(json);\n    } catch (err) {\n      data = e.data;\n    }\n\n    if (data.length >= 1) {\n      switch (data[0]) {\n        case \"EVENT\":\n          if (data.length !== 3) return; // ignore empty or malformed EVENT\n\n          const id = data[1];\n          const event = data[2];\n          if (\n            validateEvent(event) &&\n            this.openSubs[id] &&\n            (this.openSubs[id].skipVerification || verifySignature(event)) &&\n            matchFilters(this.openSubs[id].filters, event)\n          ) {\n            this.openSubs[id];\n            (this.subListeners[id]?.event || []).forEach((cb) => cb(event));\n          }\n          return;\n        case \"EOSE\": {\n          if (data.length !== 2) return; // ignore empty or malformed EOSE\n          const id = data[1];\n          (this.subListeners[id]?.eose || []).forEach((cb) => cb());\n          return;\n        }\n        case \"OK\": {\n          if (data.length < 3) return; // ignore empty or malformed OK\n          const id: string = data[1];\n          const ok: boolean = data[2];\n          const reason: string = data[3] || \"\";\n          if (ok) this.pubListeners[id]?.ok.forEach((cb) => cb());\n          else this.pubListeners[id]?.failed.forEach((cb) => cb(reason));\n          return;\n        }\n        case \"NOTICE\":\n          if (data.length !== 2) return; // ignore empty or malformed NOTICE\n          const notice = data[1];\n          this.listeners.notice.forEach((cb) => cb(notice));\n          return;\n      }\n    }\n  }\n  #onopen(opened: () => void) {\n    if (this.resolveClose) {\n      this.resolveClose();\n      return;\n    }\n    this.reconnectTimeout = 0;\n    // TODO: Send ephereal messages after subscription, permament before\n    for (const subid in this.openSubs) {\n      this.trySend([\"REQ\", subid, ...this.openSubs[subid].filters]);\n    }\n    for (const msg of this.sendOnConnect) {\n      this.ws?.send(msg);\n    }\n    this.sendOnConnect = [];\n\n    this.listeners.connect.forEach((cb) => cb());\n    opened();\n  }\n\n  async connectRelay(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const ws = new WebSocket(this.url);\n      this.ws = ws;\n\n      ws.onopen = this.#onopen.bind(this, resolve);\n      ws.onerror = () => {\n        this.listeners.error.forEach((cb) => cb());\n        reject();\n      };\n      ws.onclose = this.#onclose.bind(this);\n      ws.onmessage = this.#onmessage.bind(this);\n    });\n  }\n\n  async connect(): Promise<void> {\n    if (this.ws?.readyState && this.ws.readyState === 1) return; // ws already open\n    await this.connectRelay();\n  }\n\n  relayInit(): Relay {\n    const this2 = this;\n    return {\n      url: this2.url,\n      sub: this2.sub.bind(this2),\n      on: this2.on.bind(this2),\n      off: this2.off.bind(this2),\n      publish: this2.publish.bind(this2),\n      connect: this2.connect.bind(this2),\n      close(): Promise<void> {\n        return this2.close();\n      },\n      get status() {\n        return this2.status;\n      },\n    };\n  }\n  get status() {\n    return this.ws?.readyState ?? 3;\n  }\n  get connected() {\n    return this.ws?.readyState === 1;\n  }\n  close(): Promise<void> {\n    this.closedByClient = true;\n    if (this.connected) {\n      this.ws?.close();\n    }\n    return new Promise<void>((resolve) => {\n      this.resolveClose = resolve;\n    });\n  }\n  on(type: RelayEvent, cb: any) {\n    this.listeners[type].push(cb);\n    if (type === \"connect\" && this.ws?.readyState === 1) {\n      cb();\n    }\n  }\n\n  off(type: RelayEvent, cb: any) {\n    const index = this.listeners[type].indexOf(cb);\n    if (index !== -1) this.listeners[type].splice(index, 1);\n  }\n\n  publish(event: Event): Pub {\n    const this2 = this;\n    if (!event.id) throw new Error(`event ${event} has no id`);\n    const id = event.id;\n\n    let sent = false;\n    let mustMonitor = false;\n\n    this2\n      .trySend([\"EVENT\", event])\n      .then(() => {\n        sent = true;\n        if (mustMonitor) {\n          startMonitoring();\n          mustMonitor = false;\n        }\n      })\n      .catch(() => {});\n\n    const startMonitoring = () => {\n      const monitor = this.sub([{ids: [id]}], {\n        id: `monitor-${id.slice(0, 5)}`,\n      });\n      const willUnsub = setTimeout(() => {\n        (this2.pubListeners[id]?.failed || []).forEach((cb) =>\n          cb(\"event not seen after 5 seconds\")\n        );\n        monitor.unsub();\n      }, 5000);\n      monitor.on(\"event\", () => {\n        clearTimeout(willUnsub);\n        (this2.pubListeners[id]?.seen || []).forEach((cb) => cb());\n      });\n    };\n\n    return {\n      on: (type: \"ok\" | \"seen\" | \"failed\", cb: any) => {\n        this2.pubListeners[id] = this2.pubListeners[id] || {\n          ok: [],\n          seen: [],\n          failed: [],\n        };\n        this2.pubListeners[id][type].push(cb);\n\n        if (type === \"seen\") {\n          if (sent) startMonitoring();\n          else mustMonitor = true;\n        }\n      },\n      off: (type: \"ok\" | \"seen\" | \"failed\", cb: any) => {\n        const listeners = this2.pubListeners[id];\n        if (!listeners) return;\n        const idx = listeners[type].indexOf(cb);\n        if (idx >= 0) listeners[type].splice(idx, 1);\n      },\n    };\n  }\n\n  sub(filters: Filter[], opts: SubscriptionOptions = {}): Sub {\n    const this2 = this;\n    const subid = opts.id || Math.random().toString().slice(2);\n    const skipVerification = opts.skipVerification || false;\n\n    this2.openSubs[subid] = {\n      id: subid,\n      filters,\n      skipVerification,\n    };\n    if (this2.connected) {\n      this2.trySend([\"REQ\", subid, ...filters]);\n    }\n\n    return {\n      sub: (newFilters, newOpts = {}) =>\n        this.sub(newFilters || filters, {\n          skipVerification: newOpts.skipVerification || skipVerification,\n          id: subid,\n        }),\n      unsub: () => {\n        delete this2.openSubs[subid];\n        delete this2.subListeners[subid];\n        if (this2.connected) {\n          this2.trySend([\"CLOSE\", subid]);\n        }\n      },\n      on: (type: \"event\" | \"eose\", cb: any): void => {\n        this2.subListeners[subid] = this2.subListeners[subid] || {\n          event: [],\n          eose: [],\n        };\n        this2.subListeners[subid][type].push(cb);\n      },\n      off: (type: \"event\" | \"eose\", cb: any): void => {\n        const listeners = this2.subListeners[subid];\n        const idx = listeners[type].indexOf(cb);\n        if (idx >= 0) listeners[type].splice(idx, 1);\n      },\n    };\n  }\n}\n", "export function getHex64(json: string, field: string): string {\n  let len = field.length + 3;\n  let idx = json.indexOf(`\"${field}\":`) + len;\n  let s = json.slice(idx).indexOf(`\"`) + idx + 1;\n  return json.slice(s, s + 64);\n}\n\nexport function getSubName(json: string): string {\n  let idx = json.indexOf(`\"EVENT\"`) + 7;\n  let sliced = json.slice(idx);\n  let idx2 = sliced.indexOf(`\"`) + 1;\n  let sliced2 = sliced.slice(idx2);\n  return sliced2.slice(0, sliced2.indexOf(`\"`));\n}\n\nexport function getInt(json: string, field: string): number {\n  let len = field.length;\n  let idx = json.indexOf(`\"${field}\":`) + len + 3;\n  let sliced = json.slice(idx);\n  let end = Math.min(sliced.indexOf(\",\"), sliced.indexOf(\"}\"));\n  return parseInt(sliced.slice(0, end), 10);\n}\n\nexport function matchEventId(json: string, id: string): boolean {\n  return id === getHex64(json, \"id\");\n}\n\nexport function matchEventPubkey(json: string, pubkey: string): boolean {\n  return pubkey === getHex64(json, \"pubkey\");\n}\n\nexport function matchEventKind(json: string, kind: number): boolean {\n  return kind === getInt(json, \"kind\");\n}\n", "import {Filter, Kind} from \"nostr-tools\";\nimport {Event} from \"./event\";\n\nexport class EventCache {\n  eventsById: Map<string, Event & {id: string}> = new Map();\n  metadataByPubKey: Map<string, Event & {id: string}> = new Map();\n  contactsByPubKey: Map<string, Event & {id: string}> = new Map();\n\n  addEvent(event: Event & {id: string}) {\n    this.eventsById.set(event.id, event);\n    if (event.kind === Kind.Metadata) {\n      this.metadataByPubKey.set(event.pubkey, event);\n    }\n    if (event.kind === Kind.Contacts) {\n      this.contactsByPubKey.set(event.pubkey, event);\n    }\n  }\n\n  getEventById(id: string): (Event & {id: string}) | undefined {\n    return this.eventsById.get(id);\n  }\n\n  hasEventById(id: string): boolean {\n    return this.eventsById.has(id);\n  }\n\n  #getCachedEventsByPubKeyWithUpdatedFilter(\n    filter: Filter & {\n      relay?: string;\n      noCache?: boolean;\n    }\n  ):\n    | {filter: Filter & {relay?: string}; events: Set<Event & {id: string}>}\n    | undefined {\n    if (\n      filter.noCache ||\n      !filter.authors ||\n      !filter.kinds ||\n      filter.kinds.find(\n        (kind) => kind !== Kind.Contacts && kind !== Kind.Metadata\n      ) !== undefined\n    ) {\n      return undefined;\n    }\n    const authors: string[] = [];\n    const events = new Set<Event & {id: string}>();\n    for (const author of filter.authors) {\n      let contactEvent;\n      if (filter.kinds.includes(Kind.Contacts)) {\n        contactEvent = this.contactsByPubKey.get(author);\n        if (!contactEvent) {\n          authors.push(author);\n          continue;\n        }\n      }\n      let metadataEvent;\n      if (filter.kinds.includes(Kind.Metadata)) {\n        metadataEvent = this.metadataByPubKey.get(author);\n        if (!metadataEvent) {\n          authors.push(author);\n          continue;\n        }\n      }\n      if (contactEvent) {\n        events.add(contactEvent);\n      }\n      if (metadataEvent) {\n        events.add(metadataEvent);\n      }\n    }\n    return {filter: {...filter, authors}, events};\n  }\n\n  #getCachedEventsByIdWithUpdatedFilter(\n    filter: Filter & {relay?: string; noCache?: boolean}\n  ):\n    | {filter: Filter & {relay?: string}; events: Set<Event & {id: string}>}\n    | undefined {\n    if (!filter.ids) {\n      return undefined;\n    }\n\n    const events = new Set<Event & {id: string}>();\n    const ids: string[] = [];\n    for (const id of filter.ids) {\n      const event = this.getEventById(id);\n      if (event) {\n        events.add(event);\n      } else {\n        ids.push(id);\n      }\n    }\n    return {filter: {...filter, ids}, events};\n  }\n\n  getCachedEventsWithUpdatedFilters(\n    filters: (Filter & {relay?: string; noCache?: boolean})[],\n    relays: string[]\n  ): {\n    filters: (Filter & {relay?: string})[];\n    events: (Event & {id: string})[];\n  } {\n    const events: Set<Event & {id: string}> = new Set();\n    const new_filters: (Filter & {relay?: string})[] = [];\n    for (const filter of filters) {\n      const new_data = this.#getCachedEventsByIdWithUpdatedFilter(filter) ||\n        this.#getCachedEventsByPubKeyWithUpdatedFilter(filter) || {\n          filter,\n          events: [],\n        };\n      for (const event of new_data.events) {\n        events.add(event);\n      }\n      new_filters.push(new_data.filter);\n    }\n    return {filters: new_filters, events: [...events]};\n  }\n}\n", "import type {OnEvent, RelayPool} from \"./relay-pool\";\nimport {Filter, Kind, type Event} from \"nostr-tools\";\n\nexport class Author {\n  pubkey: string;\n  relayPool: RelayPool;\n  relays: string[];\n  constructor(relayPool: RelayPool, relays: string[], pubkey: string) {\n    this.pubkey = pubkey;\n    this.relayPool = relayPool;\n    this.relays = relays;\n  }\n\n  metaData(cb: (event: Event) => void, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          authors: [this.pubkey],\n          kinds: [Kind.Metadata],\n        },\n      ],\n      this.relays,\n      cb,\n      maxDelayms\n    );\n  }\n  subscribe(filters: Filter[], cb: OnEvent, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      filters.map((filter) => ({\n        authors: [this.pubkey],\n        ...filter,\n      })),\n      this.relays,\n      cb,\n      maxDelayms\n    );\n  }\n\n  followsPubkeys(\n    cb: (pubkeys: string[]) => void,\n    maxDelayms: number\n  ): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          authors: [this.pubkey],\n          kinds: [Kind.Contacts],\n        },\n      ],\n      this.relays,\n      (event: Event) => {\n        let r: string[] = [];\n        for (const tag of event.tags) {\n          if (tag[0] === \"p\") {\n            r.push(tag[1]);\n          }\n        }\n        cb(r);\n      },\n      maxDelayms\n    );\n  }\n\n  // TODO: prioritize relay over other relays for specific authors\n  follows(cb: (authors: Author[]) => void, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          authors: [this.pubkey],\n          kinds: [Kind.Contacts],\n        },\n      ],\n      this.relays,\n      (event: Event) => {\n        let r: Author[] = [];\n        for (const tag of event.tags) {\n          if (tag[0] === \"p\") {\n            let relays = this.relays;\n            if (tag[1]) {\n              relays = [tag[1], ...this.relays];\n            }\n            r.push(new Author(this.relayPool, relays, tag[1]));\n          }\n        }\n        cb(r);\n      },\n      maxDelayms\n    );\n  }\n\n  secondFollows(\n    cb: (pubkeysWithWeight: [string, number][]) => void,\n    maxDelayms: number,\n    removeDirectFollows = true\n  ): () => void {\n    return this.followsPubkeys((pubkeys) => {\n      let sfollows = new Map<string, number>();\n      for (const pubkey of pubkeys) {\n        this.relayPool.subscribe(\n          [\n            {\n              authors: [pubkey],\n              kinds: [Kind.Contacts],\n            },\n          ],\n          this.relays,\n          (event: Event) => {\n            let dweight = 1.0 / event.tags.length;\n            for (const tag of event.tags) {\n              if (tag[0] === \"p\") {\n                let weight = sfollows.get(tag[1]);\n                if (weight) {\n                  weight += dweight;\n                } else {\n                  weight = dweight;\n                }\n                sfollows.set(tag[1], weight);\n              }\n            }\n            if (removeDirectFollows) {\n              for (const pubkey of pubkeys) {\n                sfollows.delete(pubkey);\n              }\n            }\n            cb(Array.from(sfollows.entries()).sort((a, b) => b[1] - a[1]));\n          },\n          maxDelayms\n        );\n      }\n    }, maxDelayms);\n  }\n\n  allEvents(cb: OnEvent, limit = 100, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          authors: [this.pubkey],\n          limit,\n        },\n      ],\n      this.relays,\n      cb,\n      maxDelayms\n    );\n  }\n\n  referenced(cb: OnEvent, limit = 100, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          \"#p\": [this.pubkey],\n          limit,\n        },\n      ],\n      this.relays,\n      cb,\n      maxDelayms\n    );\n  }\n\n  followers(cb: OnEvent, limit = 100, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          \"#p\": [this.pubkey],\n          kinds: [Kind.Contacts],\n          limit,\n        },\n      ],\n      this.relays,\n      cb,\n      maxDelayms\n    );\n  }\n\n  sentAndRecievedDMs(cb: OnEvent, limit = 100, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          authors: [this.pubkey],\n          kinds: [Kind.EncryptedDirectMessage],\n          limit,\n        },\n        {\n          \"#p\": [this.pubkey],\n          kinds: [Kind.EncryptedDirectMessage],\n          limit,\n        },\n      ],\n      this.relays,\n      cb,\n      maxDelayms\n    );\n  }\n  text(cb: OnEvent, limit = 100, maxDelayms: number): () => void {\n    return this.relayPool.subscribe(\n      [\n        {\n          authors: [this.pubkey],\n          kinds: [Kind.Text],\n          limit,\n        },\n      ],\n      this.relays,\n      cb,\n      maxDelayms\n    );\n  }\n}\n", "import {Event as NostrToolsEvent, Kind} from \"nostr-tools\";\nimport {Author} from \"./author\";\nimport {RelayPool} from \"./relay-pool\";\n\nexport type {NostrToolsEvent};\nexport type NostrToolsEventWithId = NostrToolsEvent & {id: string};\nimport type {OnEvent} from \"./on-event-filters\";\nexport class Event implements NostrToolsEventWithId {\n  id: string;\n  kind: Kind;\n  pubkey: string;\n  tags: string[][];\n  created_at: number;\n  content: string;\n  relayPool: RelayPool;\n  relays: string[];\n\n  constructor(\n    event: NostrToolsEvent & {id: string},\n    relayPool: RelayPool,\n    relays: string[]\n  ) {\n    this.id = event.id;\n    this.kind = event.kind;\n    this.pubkey = event.pubkey;\n    this.tags = event.tags;\n    this.created_at = event.created_at;\n    this.content = event.content;\n    this.relayPool = relayPool;\n    this.relays = relays;\n  }\n\n  referencedAuthors(): Author[] {\n    const r: Author[] = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"p\") {\n        r.push(new Author(this.relayPool, this.relays, tag[1]));\n      }\n    }\n    return r;\n  }\n  referencedEvents(maxDelayms: number): Promise<Event>[] {\n    const r: Promise<Event>[] = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") {\n        let relays = this.relays;\n        if (tag[2]) {\n          relays = [tag[2], ...relays];\n        }\n        r.push(\n          this.relayPool\n            .getEventById(tag[1], relays, maxDelayms)\n            .then((e) => new Event(e, this.relayPool, this.relays))\n        );\n      }\n    }\n    return r;\n  }\n\n  thread(cb: OnEvent, maxDelayms: number): () => void {\n    let relays = this.relays;\n    let ids: string[] = [];\n    for (const tag of this.tags) {\n      if (tag[0] === \"e\") {\n        if (tag[2]) {\n          relays = [tag[2], ...relays];\n        }\n        ids.push(tag[1]);\n      }\n    }\n\n    return this.relayPool.subscribe(\n      [{ids}, {\"#e\": ids}],\n      relays,\n      cb,\n      maxDelayms\n    );\n  }\n}\n", "import {Filter, Kind, matchFilter} from \"nostr-tools\";\nimport {Event} from \"./event\";\nexport type OnEvent = (\n  event: Event,\n  afterEose: boolean,\n  url: string | undefined\n) => void;\n\nexport function doNotEmitDuplicateEvents(onEvent: OnEvent): OnEvent {\n  let event_ids = new Set();\n  return (event: Event, afterEose: boolean, url: string | undefined) => {\n    if (event_ids.has(event.id)) return;\n    event_ids.add(event.id);\n    onEvent(event, afterEose, url);\n  };\n}\n\nexport function doNotEmitOlderEvents(onEvent: OnEvent): OnEvent {\n  let created_at_by_events_kinds = new Map();\n  return (event: Event, afterEose: boolean, url: string | undefined) => {\n    if (event.kind === Kind.Metadata || event.kind === Kind.Contacts) {\n      let event_kind = event.pubkey + \" \" + event.kind;\n      if ((created_at_by_events_kinds.get(event_kind) || 0) > event.created_at)\n        return;\n      created_at_by_events_kinds.set(event_kind, event.created_at);\n    }\n    onEvent(event, afterEose, url);\n  };\n}\n\nexport function matchOnEventFilters(\n  onEvent: OnEvent,\n  filters: Filter[]\n): OnEvent {\n  return (event: Event, afterEose: boolean, url: string | undefined) => {\n    for (let filter of filters) {\n      if (matchFilter(filter, event)) {\n        onEvent(event, afterEose, url);\n        break;\n      }\n    }\n  };\n}\n\nexport function emitEventsOnNextTick(onEvent: OnEvent): OnEvent {\n  return (event: Event, afterEose: boolean, url: string | undefined) => {\n    setTimeout(() => {\n      onEvent(event, afterEose, url);\n    }, 0);\n  };\n}\n", "import {Filter} from \"nostr-tools\";\nimport {mergeSimilarAndRemoveEmptyFilters} from \"./merge-similar-filters\";\nimport {\n  doNotEmitDuplicateEvents,\n  doNotEmitOlderEvents,\n  matchOnEventFilters,\n  type OnEvent,\n} from \"./on-event-filters\";\nimport {EventCache} from \"./event-cache\";\nimport {Event} from \"./event\";\n\nconst unique = (arr: string[]) => [...new Set(arr)];\n\nexport function groupFiltersByRelayAndEmitCacheHits(\n  filters: (Filter & {relay?: string; noCache?: boolean})[],\n  relays: string[],\n  onEvent: OnEvent,\n  options: {allowDuplicateEvents?: boolean; allowOlderEvents?: boolean} = {},\n  eventCache?: EventCache\n): [OnEvent, Map<string, Filter[]>] {\n  let events: (Event & {id: string})[] = [];\n  if (eventCache) {\n    const cachedEventsWithUpdatedFilters =\n      eventCache.getCachedEventsWithUpdatedFilters(filters, relays);\n    filters = cachedEventsWithUpdatedFilters.filters;\n    events = cachedEventsWithUpdatedFilters.events;\n  }\n  if (!options.allowDuplicateEvents) {\n    onEvent = doNotEmitDuplicateEvents(onEvent);\n  }\n  if (!options.allowOlderEvents) {\n    onEvent = doNotEmitOlderEvents(onEvent);\n  }\n  for (const event of events) {\n    onEvent(event, false, undefined);\n  }\n  filters = mergeSimilarAndRemoveEmptyFilters(filters);\n  onEvent = matchOnEventFilters(onEvent, filters);\n  relays = unique(relays);\n  const filtersByRelay = getFiltersByRelay(filters, relays);\n  return [onEvent, filtersByRelay];\n}\n\nfunction getFiltersByRelay(\n  filters: (Filter & {relay?: string})[],\n  relays: string[]\n): Map<string, Filter[]> {\n  const filtersByRelay = new Map<string, Filter[]>();\n  const filtersWithoutRelay: Filter[] = [];\n  for (const filter of filters) {\n    const relay = filter.relay;\n    if (relay) {\n      const relayFilters = filtersByRelay.get(relay);\n      if (relayFilters) {\n        relayFilters.push(withoutRelay(filter));\n      } else {\n        filtersByRelay.set(relay, [withoutRelay(filter)]);\n      }\n    } else {\n      filtersWithoutRelay.push(filter);\n    }\n  }\n  if (filtersWithoutRelay.length > 0) {\n    for (const relay of relays) {\n      const filters = filtersByRelay.get(relay);\n      if (filters) {\n        filtersByRelay.set(relay, filters.concat(filtersWithoutRelay));\n      } else {\n        filtersByRelay.set(relay, filtersWithoutRelay);\n      }\n    }\n  }\n  return filtersByRelay;\n}\n\nfunction withoutRelay(filter: Filter & {relay?: string}): Filter {\n  filter = {...filter};\n  delete filter.relay;\n  return filter;\n}\n\nexport function batchFiltersByRelay(\n  subscribedFilters: [OnEvent, Map<string, Filter[]>][]\n): [OnEvent, Map<string, Filter[]>] {\n  const filtersByRelay = new Map<string, Filter[]>();\n  const onEvents: OnEvent[] = [];\n  for (const [onEvent, filtersByRelayBySub] of subscribedFilters) {\n    for (const [relay, filters] of filtersByRelayBySub) {\n      const filtersByRelayFilters = filtersByRelay.get(relay);\n      if (filtersByRelayFilters) {\n        filtersByRelay.set(relay, filtersByRelayFilters.concat(filters));\n      } else {\n        filtersByRelay.set(relay, filters);\n      }\n    }\n    onEvents.push(onEvent);\n  }\n  const onEvent: OnEvent = (event, afterEose, url) => {\n    for (const onEvent of onEvents) {\n      onEvent(event, afterEose, url);\n    }\n  };\n  return [onEvent, filtersByRelay];\n}\n", "import {Event} from \"./event\";\nimport {OnEvent} from \"./on-event-filters\";\n\nconst binarySearch = function (a: Event[], target: Event) {\n  var l = 0,\n    h = a.length - 1,\n    m,\n    comparison;\n  let comparator = function (a: Event, b: Event) {\n    return a.created_at - b.created_at;\n  };\n  while (l <= h) {\n    m = (l + h) >>> 1; /* equivalent to Math.floor((l + h) / 2) but faster */\n    comparison = comparator(a[m], target);\n    if (comparison < 0) {\n      l = m + 1;\n    } else if (comparison > 0) {\n      h = m - 1;\n    } else {\n      return m;\n    }\n  }\n  return ~l;\n};\n\nconst binaryInsert = function (a: Event[], target: Event) {\n  const duplicate = true; // it's OK to have the same created_at multiple times\n  var i = binarySearch(a, target);\n  if (i >= 0) {\n    /* if the binarySearch return value was zero or positive, a matching object was found */\n    if (!duplicate) {\n      return i;\n    }\n  } else {\n    /* if the return value was negative, the bitwise complement of the return value is the correct index for this object */\n    i = ~i;\n  }\n  a.splice(i, 0, target);\n  return i;\n};\n\nexport function collect(\n  onEvents: (events: Event[]) => void,\n  skipSort: boolean = false\n): OnEvent {\n  let events: Event[] = [];\n  return (event: Event, afterEose: boolean, url: string | undefined) => {\n    if (skipSort) {\n      events.push(event);\n    } else {\n      binaryInsert(events, event);\n    }\n    onEvents(events);\n  };\n}\n"],
  "mappings": ";AAAA,SAAgB,oBAAwB;;;ACAxC,SAAQ,iBAAgB;AAGxB,SAAS,eAAe,QAAgB,KAAqB;AAC3D,MAAI,aAAa,EAAC,GAAG,OAAM;AAE3B,SAAO,WAAW;AAClB,SAAO,MAAM,UAAU,UAAU;AACnC;AAEO,SAAS,kCAAkC,SAA6B;AAC7E,MAAI,IAAI,CAAC;AACT,MAAI,gBAAgB,oBAAI,IAAoB;AAC5C,WAAS,UAAU,SAAS;AAC1B,QAAI,QAAQ;AACZ,aAAS,OAAO,QAAQ;AACtB,UAEE,OAAO,SACN,CAAC,OAAO,WAAW,OAAO,EAAE,SAAS,GAAG,KAAK,IAAI,WAAW,GAAG,IAChE;AAEA,YAAI,OAAO,KAAK,WAAW,GAAG;AAC5B,kBAAQ;AACR;AAAA,QACF;AACA,YAAI,WAAW,eAAe,QAAQ,GAAG;AACzC,YAAI,QAAQ,cAAc,IAAI,QAAQ;AACtC,YAAI,UAAU,QAAW;AAEvB,cAAI,iBAAiB,EAAE;AAEvB,mBAAS,QAAQ,gBAAgB;AAC/B,gBAAI,SAAS,KAAK;AAChB,kBAAI,YAAY,eAAe,gBAAgB,IAAI;AACnD,4BAAc,OAAO,SAAS;AAAA,YAChC;AAAA,UACF;AAEA,YAAE,OAAO,OAAO,CAAC,GAAG,IAAI,IAAI,EAAE,OAAO,KAAK,OAAO,OAAO,IAAI,CAAC,CAAC;AAC9D,kBAAQ;AACR;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,CAAC,OAAO;AACV,eAAS,OAAO,QAAQ;AACtB,YAEE,OAAO,SACN,CAAC,OAAO,WAAW,OAAO,EAAE,SAAS,GAAG,KAAK,IAAI,WAAW,GAAG,IAChE;AACA,cAAI,WAAW,eAAe,QAAQ,GAAG;AACzC,wBAAc,IAAI,UAAU,EAAE,MAAM;AAAA,QACtC;AAAA,MACF;AACA,QAAE,KAAK,MAAM;AAAA,IACf;AAAA,EACF;AACA,SAAO;AACT;;;ACvDA,SAAoB,iBAAiB,qBAAoB;AACzD,SAAqB,oBAAmB;AACxC,OAAO,eAAe;;;ACPf,SAAS,SAAS,MAAc,OAAuB;AAC5D,MAAI,MAAM,MAAM,SAAS;AACzB,MAAI,MAAM,KAAK,QAAQ,IAAI,SAAS,IAAI;AACxC,MAAI,IAAI,KAAK,MAAM,GAAG,EAAE,QAAQ,GAAG,IAAI,MAAM;AAC7C,SAAO,KAAK,MAAM,GAAG,IAAI,EAAE;AAC7B;AAEO,SAAS,WAAW,MAAsB;AAC/C,MAAI,MAAM,KAAK,QAAQ,SAAS,IAAI;AACpC,MAAI,SAAS,KAAK,MAAM,GAAG;AAC3B,MAAI,OAAO,OAAO,QAAQ,GAAG,IAAI;AACjC,MAAI,UAAU,OAAO,MAAM,IAAI;AAC/B,SAAO,QAAQ,MAAM,GAAG,QAAQ,QAAQ,GAAG,CAAC;AAC9C;;;ADwBO,SAAS,UACd,KACA,kBACA,mBACO;AACP,SAAO,IAAI,OAAO,KAAK,kBAAkB,iBAAiB,EAAE,UAAU;AACxE;AACA,IAAM,SAAN,MAAa;AAAA,EACX;AAAA,EACA;AAAA,EACA,YACE,KACA,kBACA,mBACA;AACA,SAAK,MAAM;AACX,SAAK,mBAAmB;AACxB,SAAK,oBAAoB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EACA,gBAA0B,CAAC;AAAA,EAC3B,WAAsE,CAAC;AAAA,EACvE,iBAA0B;AAAA,EAC1B,YAKI;AAAA,IACF,SAAS,CAAC;AAAA,IACV,YAAY,CAAC;AAAA,IACb,OAAO,CAAC;AAAA,IACR,QAAQ,CAAC;AAAA,EACX;AAAA,EACA,eAKI,CAAC;AAAA,EACL,eAMI,CAAC;AAAA,EACL,uBAAiC,CAAC;AAAA,EAClC;AAAA,EAEA,cAAc;AACZ,QAAI,KAAK,qBAAqB,WAAW,GAAG;AAC1C,oBAAc,KAAK,kBAAkB;AACrC,WAAK,qBAAqB;AAC1B;AAAA,IACF;AACA,SAAK,eAAe,EAAC,MAAM,KAAK,qBAAqB,MAAM,EAAC,CAAC;AAAA,EAC/D;AAAA,EAEA,MAAM,QAAQ,QAA0B;AACtC,UAAM,MAAM,KAAK,UAAU,MAAM;AAEjC,QAAI,KAAK,WAAW;AAClB,WAAK,IAAI,KAAK,GAAG;AAAA,IACnB,OAAO;AACL,WAAK,cAAc,KAAK,GAAG;AAAA,IAC7B;AAAA,EACF;AAAA,EACA,eAAyC;AAAA,EAEzC,MAAM,WAAW;AACf,QAAI,KAAK,gBAAgB;AACvB,WAAK,UAAU,WAAW,QAAQ,CAAC,OAAO,GAAG,CAAC;AAC9C,WAAK,gBAAgB,KAAK,aAAa;AAAA,IACzC,OAAO;AACL,UAAI,CAAC,KAAK,mBAAmB;AAC3B,aAAK,WAAW;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AAAA,EACA,mBAA2B;AAAA,EAC3B,aAAa;AACX,eAAW,MAAM;AACf,WAAK,mBAAmB,KAAK,IAAI,KAAM,KAAK,mBAAmB,CAAC;AAChE,WAAK,QAAQ;AAAA,IACf,GAAG,KAAK,gBAAgB;AAAA,EAC1B;AAAA,EAEA,MAAM,WAAW,GAAQ;AACvB,SAAK,qBAAqB,KAAK,EAAE,IAAI;AACrC,QAAI,CAAC,KAAK,oBAAoB;AAC5B,WAAK,qBAAqB,YAAY,MAAM,KAAK,YAAY,GAAG,CAAC;AAAA,IACnE;AAAA,EACF;AAAA,EAEA,MAAM,eAAe,GAAQ;AAC3B,QAAI;AACJ,QAAI,OAAe,EAAE,KAAK,SAAS;AACnC,QAAI,CAAC,MAAM;AACT;AAAA,IACF;AACA,QAAI,QACF,KAAK,oBAAoB,KAAK,iBAAiB,SAAS,MAAM,IAAI,CAAC;AACrE,QAAI,OAAO;AACT,aAAO,KAAK,aAAa,WAAW,IAAI,GAAG,MAAM;AAAA,QAAQ,CAAC,OAExD,GAAG,KAAK;AAAA,MACV;AAAA,IACF;AACA,QAAI;AACF,aAAO,KAAK,MAAM,IAAI;AAAA,IACxB,SAAS,KAAP;AACA,aAAO,EAAE;AAAA,IACX;AAEA,QAAI,KAAK,UAAU,GAAG;AACpB,cAAQ,KAAK,IAAI;AAAA,QACf,KAAK;AACH,cAAI,KAAK,WAAW;AAAG;AAEvB,gBAAM,KAAK,KAAK;AAChB,gBAAMA,SAAQ,KAAK;AACnB,cACE,cAAcA,MAAK,KACnB,KAAK,SAAS,QACb,KAAK,SAAS,IAAI,oBAAoB,gBAAgBA,MAAK,MAC5D,aAAa,KAAK,SAAS,IAAI,SAASA,MAAK,GAC7C;AACA,iBAAK,SAAS;AACd,aAAC,KAAK,aAAa,KAAK,SAAS,CAAC,GAAG,QAAQ,CAAC,OAAO,GAAGA,MAAK,CAAC;AAAA,UAChE;AACA;AAAA,QACF,KAAK,QAAQ;AACX,cAAI,KAAK,WAAW;AAAG;AACvB,gBAAMC,MAAK,KAAK;AAChB,WAAC,KAAK,aAAaA,MAAK,QAAQ,CAAC,GAAG,QAAQ,CAAC,OAAO,GAAG,CAAC;AACxD;AAAA,QACF;AAAA,QACA,KAAK,MAAM;AACT,cAAI,KAAK,SAAS;AAAG;AACrB,gBAAMA,MAAa,KAAK;AACxB,gBAAM,KAAc,KAAK;AACzB,gBAAM,SAAiB,KAAK,MAAM;AAClC,cAAI;AAAI,iBAAK,aAAaA,MAAK,GAAG,QAAQ,CAAC,OAAO,GAAG,CAAC;AAAA;AACjD,iBAAK,aAAaA,MAAK,OAAO,QAAQ,CAAC,OAAO,GAAG,MAAM,CAAC;AAC7D;AAAA,QACF;AAAA,QACA,KAAK;AACH,cAAI,KAAK,WAAW;AAAG;AACvB,gBAAM,SAAS,KAAK;AACpB,eAAK,UAAU,OAAO,QAAQ,CAAC,OAAO,GAAG,MAAM,CAAC;AAChD;AAAA,MACJ;AAAA,IACF;AAAA,EACF;AAAA,EACA,QAAQ,QAAoB;AAC1B,QAAI,KAAK,cAAc;AACrB,WAAK,aAAa;AAClB;AAAA,IACF;AACA,SAAK,mBAAmB;AAExB,eAAW,SAAS,KAAK,UAAU;AACjC,WAAK,QAAQ,CAAC,OAAO,OAAO,GAAG,KAAK,SAAS,OAAO,OAAO,CAAC;AAAA,IAC9D;AACA,eAAW,OAAO,KAAK,eAAe;AACpC,WAAK,IAAI,KAAK,GAAG;AAAA,IACnB;AACA,SAAK,gBAAgB,CAAC;AAEtB,SAAK,UAAU,QAAQ,QAAQ,CAAC,OAAO,GAAG,CAAC;AAC3C,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,eAA8B;AAClC,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,YAAM,KAAK,IAAI,UAAU,KAAK,GAAG;AACjC,WAAK,KAAK;AAEV,SAAG,SAAS,KAAK,QAAQ,KAAK,MAAM,OAAO;AAC3C,SAAG,UAAU,MAAM;AACjB,aAAK,UAAU,MAAM,QAAQ,CAAC,OAAO,GAAG,CAAC;AACzC,eAAO;AAAA,MACT;AACA,SAAG,UAAU,KAAK,SAAS,KAAK,IAAI;AACpC,SAAG,YAAY,KAAK,WAAW,KAAK,IAAI;AAAA,IAC1C,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,UAAyB;AAC7B,QAAI,KAAK,IAAI,cAAc,KAAK,GAAG,eAAe;AAAG;AACrD,UAAM,KAAK,aAAa;AAAA,EAC1B;AAAA,EAEA,YAAmB;AACjB,UAAM,QAAQ;AACd,WAAO;AAAA,MACL,KAAK,MAAM;AAAA,MACX,KAAK,MAAM,IAAI,KAAK,KAAK;AAAA,MACzB,IAAI,MAAM,GAAG,KAAK,KAAK;AAAA,MACvB,KAAK,MAAM,IAAI,KAAK,KAAK;AAAA,MACzB,SAAS,MAAM,QAAQ,KAAK,KAAK;AAAA,MACjC,SAAS,MAAM,QAAQ,KAAK,KAAK;AAAA,MACjC,QAAuB;AACrB,eAAO,MAAM,MAAM;AAAA,MACrB;AAAA,MACA,IAAI,SAAS;AACX,eAAO,MAAM;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA,EACA,IAAI,SAAS;AACX,WAAO,KAAK,IAAI,cAAc;AAAA,EAChC;AAAA,EACA,IAAI,YAAY;AACd,WAAO,KAAK,IAAI,eAAe;AAAA,EACjC;AAAA,EACA,QAAuB;AACrB,SAAK,iBAAiB;AACtB,QAAI,KAAK,WAAW;AAClB,WAAK,IAAI,MAAM;AAAA,IACjB;AACA,WAAO,IAAI,QAAc,CAAC,YAAY;AACpC,WAAK,eAAe;AAAA,IACtB,CAAC;AAAA,EACH;AAAA,EACA,GAAG,MAAkB,IAAS;AAC5B,SAAK,UAAU,MAAM,KAAK,EAAE;AAC5B,QAAI,SAAS,aAAa,KAAK,IAAI,eAAe,GAAG;AACnD,SAAG;AAAA,IACL;AAAA,EACF;AAAA,EAEA,IAAI,MAAkB,IAAS;AAC7B,UAAM,QAAQ,KAAK,UAAU,MAAM,QAAQ,EAAE;AAC7C,QAAI,UAAU;AAAI,WAAK,UAAU,MAAM,OAAO,OAAO,CAAC;AAAA,EACxD;AAAA,EAEA,QAAQ,OAAmB;AACzB,UAAM,QAAQ;AACd,QAAI,CAAC,MAAM;AAAI,YAAM,IAAI,MAAM,SAAS,iBAAiB;AACzD,UAAM,KAAK,MAAM;AAEjB,QAAI,OAAO;AACX,QAAI,cAAc;AAElB,UACG,QAAQ,CAAC,SAAS,KAAK,CAAC,EACxB,KAAK,MAAM;AACV,aAAO;AACP,UAAI,aAAa;AACf,wBAAgB;AAChB,sBAAc;AAAA,MAChB;AAAA,IACF,CAAC,EACA,MAAM,MAAM;AAAA,IAAC,CAAC;AAEjB,UAAM,kBAAkB,MAAM;AAC5B,YAAM,UAAU,KAAK,IAAI,CAAC,EAAC,KAAK,CAAC,EAAE,EAAC,CAAC,GAAG;AAAA,QACtC,IAAI,WAAW,GAAG,MAAM,GAAG,CAAC;AAAA,MAC9B,CAAC;AACD,YAAM,YAAY,WAAW,MAAM;AACjC,SAAC,MAAM,aAAa,KAAK,UAAU,CAAC,GAAG;AAAA,UAAQ,CAAC,OAC9C,GAAG,gCAAgC;AAAA,QACrC;AACA,gBAAQ,MAAM;AAAA,MAChB,GAAG,GAAI;AACP,cAAQ,GAAG,SAAS,MAAM;AACxB,qBAAa,SAAS;AACtB,SAAC,MAAM,aAAa,KAAK,QAAQ,CAAC,GAAG,QAAQ,CAAC,OAAO,GAAG,CAAC;AAAA,MAC3D,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,MACL,IAAI,CAAC,MAAgC,OAAY;AAC/C,cAAM,aAAa,MAAM,MAAM,aAAa,OAAO;AAAA,UACjD,IAAI,CAAC;AAAA,UACL,MAAM,CAAC;AAAA,UACP,QAAQ,CAAC;AAAA,QACX;AACA,cAAM,aAAa,IAAI,MAAM,KAAK,EAAE;AAEpC,YAAI,SAAS,QAAQ;AACnB,cAAI;AAAM,4BAAgB;AAAA;AACrB,0BAAc;AAAA,QACrB;AAAA,MACF;AAAA,MACA,KAAK,CAAC,MAAgC,OAAY;AAChD,cAAM,YAAY,MAAM,aAAa;AACrC,YAAI,CAAC;AAAW;AAChB,cAAM,MAAM,UAAU,MAAM,QAAQ,EAAE;AACtC,YAAI,OAAO;AAAG,oBAAU,MAAM,OAAO,KAAK,CAAC;AAAA,MAC7C;AAAA,IACF;AAAA,EACF;AAAA,EAEA,IAAI,SAAmB,OAA4B,CAAC,GAAQ;AAC1D,UAAM,QAAQ;AACd,UAAM,QAAQ,KAAK,MAAM,KAAK,OAAO,EAAE,SAAS,EAAE,MAAM,CAAC;AACzD,UAAM,mBAAmB,KAAK,oBAAoB;AAElD,UAAM,SAAS,SAAS;AAAA,MACtB,IAAI;AAAA,MACJ;AAAA,MACA;AAAA,IACF;AACA,QAAI,MAAM,WAAW;AACnB,YAAM,QAAQ,CAAC,OAAO,OAAO,GAAG,OAAO,CAAC;AAAA,IAC1C;AAEA,WAAO;AAAA,MACL,KAAK,CAAC,YAAY,UAAU,CAAC,MAC3B,KAAK,IAAI,cAAc,SAAS;AAAA,QAC9B,kBAAkB,QAAQ,oBAAoB;AAAA,QAC9C,IAAI;AAAA,MACN,CAAC;AAAA,MACH,OAAO,MAAM;AACX,eAAO,MAAM,SAAS;AACtB,eAAO,MAAM,aAAa;AAC1B,YAAI,MAAM,WAAW;AACnB,gBAAM,QAAQ,CAAC,SAAS,KAAK,CAAC;AAAA,QAChC;AAAA,MACF;AAAA,MACA,IAAI,CAAC,MAAwB,OAAkB;AAC7C,cAAM,aAAa,SAAS,MAAM,aAAa,UAAU;AAAA,UACvD,OAAO,CAAC;AAAA,UACR,MAAM,CAAC;AAAA,QACT;AACA,cAAM,aAAa,OAAO,MAAM,KAAK,EAAE;AAAA,MACzC;AAAA,MACA,KAAK,CAAC,MAAwB,OAAkB;AAC9C,cAAM,YAAY,MAAM,aAAa;AACrC,cAAM,MAAM,UAAU,MAAM,QAAQ,EAAE;AACtC,YAAI,OAAO;AAAG,oBAAU,MAAM,OAAO,KAAK,CAAC;AAAA,MAC7C;AAAA,IACF;AAAA,EACF;AACF;;;AEvXA,SAAgB,YAAW;AAGpB,IAAM,aAAN,MAAiB;AAAA,EACtB,aAAgD,oBAAI,IAAI;AAAA,EACxD,mBAAsD,oBAAI,IAAI;AAAA,EAC9D,mBAAsD,oBAAI,IAAI;AAAA,EAE9D,SAAS,OAA6B;AACpC,SAAK,WAAW,IAAI,MAAM,IAAI,KAAK;AACnC,QAAI,MAAM,SAAS,KAAK,UAAU;AAChC,WAAK,iBAAiB,IAAI,MAAM,QAAQ,KAAK;AAAA,IAC/C;AACA,QAAI,MAAM,SAAS,KAAK,UAAU;AAChC,WAAK,iBAAiB,IAAI,MAAM,QAAQ,KAAK;AAAA,IAC/C;AAAA,EACF;AAAA,EAEA,aAAa,IAAgD;AAC3D,WAAO,KAAK,WAAW,IAAI,EAAE;AAAA,EAC/B;AAAA,EAEA,aAAa,IAAqB;AAChC,WAAO,KAAK,WAAW,IAAI,EAAE;AAAA,EAC/B;AAAA,EAEA,0CACE,QAMY;AACZ,QACE,OAAO,WACP,CAAC,OAAO,WACR,CAAC,OAAO,SACR,OAAO,MAAM;AAAA,MACX,CAAC,SAAS,SAAS,KAAK,YAAY,SAAS,KAAK;AAAA,IACpD,MAAM,QACN;AACA,aAAO;AAAA,IACT;AACA,UAAM,UAAoB,CAAC;AAC3B,UAAM,SAAS,oBAAI,IAA0B;AAC7C,eAAW,UAAU,OAAO,SAAS;AACnC,UAAI;AACJ,UAAI,OAAO,MAAM,SAAS,KAAK,QAAQ,GAAG;AACxC,uBAAe,KAAK,iBAAiB,IAAI,MAAM;AAC/C,YAAI,CAAC,cAAc;AACjB,kBAAQ,KAAK,MAAM;AACnB;AAAA,QACF;AAAA,MACF;AACA,UAAI;AACJ,UAAI,OAAO,MAAM,SAAS,KAAK,QAAQ,GAAG;AACxC,wBAAgB,KAAK,iBAAiB,IAAI,MAAM;AAChD,YAAI,CAAC,eAAe;AAClB,kBAAQ,KAAK,MAAM;AACnB;AAAA,QACF;AAAA,MACF;AACA,UAAI,cAAc;AAChB,eAAO,IAAI,YAAY;AAAA,MACzB;AACA,UAAI,eAAe;AACjB,eAAO,IAAI,aAAa;AAAA,MAC1B;AAAA,IACF;AACA,WAAO,EAAC,QAAQ,EAAC,GAAG,QAAQ,QAAO,GAAG,OAAM;AAAA,EAC9C;AAAA,EAEA,sCACE,QAGY;AACZ,QAAI,CAAC,OAAO,KAAK;AACf,aAAO;AAAA,IACT;AAEA,UAAM,SAAS,oBAAI,IAA0B;AAC7C,UAAM,MAAgB,CAAC;AACvB,eAAW,MAAM,OAAO,KAAK;AAC3B,YAAM,QAAQ,KAAK,aAAa,EAAE;AAClC,UAAI,OAAO;AACT,eAAO,IAAI,KAAK;AAAA,MAClB,OAAO;AACL,YAAI,KAAK,EAAE;AAAA,MACb;AAAA,IACF;AACA,WAAO,EAAC,QAAQ,EAAC,GAAG,QAAQ,IAAG,GAAG,OAAM;AAAA,EAC1C;AAAA,EAEA,kCACE,SACA,QAIA;AACA,UAAM,SAAoC,oBAAI,IAAI;AAClD,UAAM,cAA6C,CAAC;AACpD,eAAW,UAAU,SAAS;AAC5B,YAAM,WAAW,KAAK,sCAAsC,MAAM,KAChE,KAAK,0CAA0C,MAAM,KAAK;AAAA,QACxD;AAAA,QACA,QAAQ,CAAC;AAAA,MACX;AACF,iBAAW,SAAS,SAAS,QAAQ;AACnC,eAAO,IAAI,KAAK;AAAA,MAClB;AACA,kBAAY,KAAK,SAAS,MAAM;AAAA,IAClC;AACA,WAAO,EAAC,SAAS,aAAa,QAAQ,CAAC,GAAG,MAAM,EAAC;AAAA,EACnD;AACF;;;ACpHA,SAAgB,QAAAC,aAAuB;AAEhC,IAAM,SAAN,MAAa;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA,YAAY,WAAsB,QAAkB,QAAgB;AAClE,SAAK,SAAS;AACd,SAAK,YAAY;AACjB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,SAAS,IAA4B,YAAgC;AACnE,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,SAAS,CAAC,KAAK,MAAM;AAAA,UACrB,OAAO,CAACA,MAAK,QAAQ;AAAA,QACvB;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,UAAU,SAAmB,IAAa,YAAgC;AACxE,WAAO,KAAK,UAAU;AAAA,MACpB,QAAQ,IAAI,CAAC,YAAY;AAAA,QACvB,SAAS,CAAC,KAAK,MAAM;AAAA,QACrB,GAAG;AAAA,MACL,EAAE;AAAA,MACF,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,eACE,IACA,YACY;AACZ,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,SAAS,CAAC,KAAK,MAAM;AAAA,UACrB,OAAO,CAACA,MAAK,QAAQ;AAAA,QACvB;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL,CAAC,UAAiB;AAChB,YAAI,IAAc,CAAC;AACnB,mBAAW,OAAO,MAAM,MAAM;AAC5B,cAAI,IAAI,OAAO,KAAK;AAClB,cAAE,KAAK,IAAI,EAAE;AAAA,UACf;AAAA,QACF;AACA,WAAG,CAAC;AAAA,MACN;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAGA,QAAQ,IAAiC,YAAgC;AACvE,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,SAAS,CAAC,KAAK,MAAM;AAAA,UACrB,OAAO,CAACA,MAAK,QAAQ;AAAA,QACvB;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL,CAAC,UAAiB;AAChB,YAAI,IAAc,CAAC;AACnB,mBAAW,OAAO,MAAM,MAAM;AAC5B,cAAI,IAAI,OAAO,KAAK;AAClB,gBAAI,SAAS,KAAK;AAClB,gBAAI,IAAI,IAAI;AACV,uBAAS,CAAC,IAAI,IAAI,GAAG,KAAK,MAAM;AAAA,YAClC;AACA,cAAE,KAAK,IAAI,OAAO,KAAK,WAAW,QAAQ,IAAI,EAAE,CAAC;AAAA,UACnD;AAAA,QACF;AACA,WAAG,CAAC;AAAA,MACN;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cACE,IACA,YACA,sBAAsB,MACV;AACZ,WAAO,KAAK,eAAe,CAAC,YAAY;AACtC,UAAI,WAAW,oBAAI,IAAoB;AACvC,iBAAW,UAAU,SAAS;AAC5B,aAAK,UAAU;AAAA,UACb;AAAA,YACE;AAAA,cACE,SAAS,CAAC,MAAM;AAAA,cAChB,OAAO,CAACA,MAAK,QAAQ;AAAA,YACvB;AAAA,UACF;AAAA,UACA,KAAK;AAAA,UACL,CAAC,UAAiB;AAChB,gBAAI,UAAU,IAAM,MAAM,KAAK;AAC/B,uBAAW,OAAO,MAAM,MAAM;AAC5B,kBAAI,IAAI,OAAO,KAAK;AAClB,oBAAI,SAAS,SAAS,IAAI,IAAI,EAAE;AAChC,oBAAI,QAAQ;AACV,4BAAU;AAAA,gBACZ,OAAO;AACL,2BAAS;AAAA,gBACX;AACA,yBAAS,IAAI,IAAI,IAAI,MAAM;AAAA,cAC7B;AAAA,YACF;AACA,gBAAI,qBAAqB;AACvB,yBAAWC,WAAU,SAAS;AAC5B,yBAAS,OAAOA,OAAM;AAAA,cACxB;AAAA,YACF;AACA,eAAG,MAAM,KAAK,SAAS,QAAQ,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC;AAAA,UAC/D;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAAA,IACF,GAAG,UAAU;AAAA,EACf;AAAA,EAEA,UAAU,IAAa,QAAQ,KAAK,YAAgC;AAClE,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,SAAS,CAAC,KAAK,MAAM;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,WAAW,IAAa,QAAQ,KAAK,YAAgC;AACnE,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,MAAM,CAAC,KAAK,MAAM;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,UAAU,IAAa,QAAQ,KAAK,YAAgC;AAClE,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,MAAM,CAAC,KAAK,MAAM;AAAA,UAClB,OAAO,CAACD,MAAK,QAAQ;AAAA,UACrB;AAAA,QACF;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EAEA,mBAAmB,IAAa,QAAQ,KAAK,YAAgC;AAC3E,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,SAAS,CAAC,KAAK,MAAM;AAAA,UACrB,OAAO,CAACA,MAAK,sBAAsB;AAAA,UACnC;AAAA,QACF;AAAA,QACA;AAAA,UACE,MAAM,CAAC,KAAK,MAAM;AAAA,UAClB,OAAO,CAACA,MAAK,sBAAsB;AAAA,UACnC;AAAA,QACF;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA,EACA,KAAK,IAAa,QAAQ,KAAK,YAAgC;AAC7D,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,QACE;AAAA,UACE,SAAS,CAAC,KAAK,MAAM;AAAA,UACrB,OAAO,CAACA,MAAK,IAAI;AAAA,UACjB;AAAA,QACF;AAAA,MACF;AAAA,MACA,KAAK;AAAA,MACL;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;ACzMO,IAAM,QAAN,MAA6C;AAAA,EAClD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YACE,OACA,WACA,QACA;AACA,SAAK,KAAK,MAAM;AAChB,SAAK,OAAO,MAAM;AAClB,SAAK,SAAS,MAAM;AACpB,SAAK,OAAO,MAAM;AAClB,SAAK,aAAa,MAAM;AACxB,SAAK,UAAU,MAAM;AACrB,SAAK,YAAY;AACjB,SAAK,SAAS;AAAA,EAChB;AAAA,EAEA,oBAA8B;AAC5B,UAAM,IAAc,CAAC;AACrB,eAAW,OAAO,KAAK,MAAM;AAC3B,UAAI,IAAI,OAAO,KAAK;AAClB,UAAE,KAAK,IAAI,OAAO,KAAK,WAAW,KAAK,QAAQ,IAAI,EAAE,CAAC;AAAA,MACxD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EACA,iBAAiB,YAAsC;AACrD,UAAM,IAAsB,CAAC;AAC7B,eAAW,OAAO,KAAK,MAAM;AAC3B,UAAI,IAAI,OAAO,KAAK;AAClB,YAAI,SAAS,KAAK;AAClB,YAAI,IAAI,IAAI;AACV,mBAAS,CAAC,IAAI,IAAI,GAAG,MAAM;AAAA,QAC7B;AACA,UAAE;AAAA,UACA,KAAK,UACF,aAAa,IAAI,IAAI,QAAQ,UAAU,EACvC,KAAK,CAAC,MAAM,IAAI,MAAM,GAAG,KAAK,WAAW,KAAK,MAAM,CAAC;AAAA,QAC1D;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,IAAa,YAAgC;AAClD,QAAI,SAAS,KAAK;AAClB,QAAI,MAAgB,CAAC;AACrB,eAAW,OAAO,KAAK,MAAM;AAC3B,UAAI,IAAI,OAAO,KAAK;AAClB,YAAI,IAAI,IAAI;AACV,mBAAS,CAAC,IAAI,IAAI,GAAG,MAAM;AAAA,QAC7B;AACA,YAAI,KAAK,IAAI,EAAE;AAAA,MACjB;AAAA,IACF;AAEA,WAAO,KAAK,UAAU;AAAA,MACpB,CAAC,EAAC,IAAG,GAAG,EAAC,MAAM,IAAG,CAAC;AAAA,MACnB;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;;;AC9EA,SAAgB,QAAAE,OAAM,mBAAkB;AAQjC,SAAS,yBAAyB,SAA2B;AAClE,MAAI,YAAY,oBAAI,IAAI;AACxB,SAAO,CAAC,OAAc,WAAoB,QAA4B;AACpE,QAAI,UAAU,IAAI,MAAM,EAAE;AAAG;AAC7B,cAAU,IAAI,MAAM,EAAE;AACtB,YAAQ,OAAO,WAAW,GAAG;AAAA,EAC/B;AACF;AAEO,SAAS,qBAAqB,SAA2B;AAC9D,MAAI,6BAA6B,oBAAI,IAAI;AACzC,SAAO,CAAC,OAAc,WAAoB,QAA4B;AACpE,QAAI,MAAM,SAASA,MAAK,YAAY,MAAM,SAASA,MAAK,UAAU;AAChE,UAAI,aAAa,MAAM,SAAS,MAAM,MAAM;AAC5C,WAAK,2BAA2B,IAAI,UAAU,KAAK,KAAK,MAAM;AAC5D;AACF,iCAA2B,IAAI,YAAY,MAAM,UAAU;AAAA,IAC7D;AACA,YAAQ,OAAO,WAAW,GAAG;AAAA,EAC/B;AACF;AAEO,SAAS,oBACd,SACA,SACS;AACT,SAAO,CAAC,OAAc,WAAoB,QAA4B;AACpE,aAAS,UAAU,SAAS;AAC1B,UAAI,YAAY,QAAQ,KAAK,GAAG;AAC9B,gBAAQ,OAAO,WAAW,GAAG;AAC7B;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AAEO,SAAS,qBAAqB,SAA2B;AAC9D,SAAO,CAAC,OAAc,WAAoB,QAA4B;AACpE,eAAW,MAAM;AACf,cAAQ,OAAO,WAAW,GAAG;AAAA,IAC/B,GAAG,CAAC;AAAA,EACN;AACF;;;ACvCA,IAAM,SAAS,CAAC,QAAkB,CAAC,GAAG,IAAI,IAAI,GAAG,CAAC;AAE3C,SAAS,oCACd,SACA,QACA,SACA,UAAwE,CAAC,GACzE,YACkC;AAClC,MAAI,SAAmC,CAAC;AACxC,MAAI,YAAY;AACd,UAAM,iCACJ,WAAW,kCAAkC,SAAS,MAAM;AAC9D,cAAU,+BAA+B;AACzC,aAAS,+BAA+B;AAAA,EAC1C;AACA,MAAI,CAAC,QAAQ,sBAAsB;AACjC,cAAU,yBAAyB,OAAO;AAAA,EAC5C;AACA,MAAI,CAAC,QAAQ,kBAAkB;AAC7B,cAAU,qBAAqB,OAAO;AAAA,EACxC;AACA,aAAW,SAAS,QAAQ;AAC1B,YAAQ,OAAO,OAAO,MAAS;AAAA,EACjC;AACA,YAAU,kCAAkC,OAAO;AACnD,YAAU,oBAAoB,SAAS,OAAO;AAC9C,WAAS,OAAO,MAAM;AACtB,QAAM,iBAAiB,kBAAkB,SAAS,MAAM;AACxD,SAAO,CAAC,SAAS,cAAc;AACjC;AAEA,SAAS,kBACP,SACA,QACuB;AACvB,QAAM,iBAAiB,oBAAI,IAAsB;AACjD,QAAM,sBAAgC,CAAC;AACvC,aAAW,UAAU,SAAS;AAC5B,UAAM,QAAQ,OAAO;AACrB,QAAI,OAAO;AACT,YAAM,eAAe,eAAe,IAAI,KAAK;AAC7C,UAAI,cAAc;AAChB,qBAAa,KAAK,aAAa,MAAM,CAAC;AAAA,MACxC,OAAO;AACL,uBAAe,IAAI,OAAO,CAAC,aAAa,MAAM,CAAC,CAAC;AAAA,MAClD;AAAA,IACF,OAAO;AACL,0BAAoB,KAAK,MAAM;AAAA,IACjC;AAAA,EACF;AACA,MAAI,oBAAoB,SAAS,GAAG;AAClC,eAAW,SAAS,QAAQ;AAC1B,YAAMC,WAAU,eAAe,IAAI,KAAK;AACxC,UAAIA,UAAS;AACX,uBAAe,IAAI,OAAOA,SAAQ,OAAO,mBAAmB,CAAC;AAAA,MAC/D,OAAO;AACL,uBAAe,IAAI,OAAO,mBAAmB;AAAA,MAC/C;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAEA,SAAS,aAAa,QAA2C;AAC/D,WAAS,EAAC,GAAG,OAAM;AACnB,SAAO,OAAO;AACd,SAAO;AACT;AAEO,SAAS,oBACd,mBACkC;AAClC,QAAM,iBAAiB,oBAAI,IAAsB;AACjD,QAAM,WAAsB,CAAC;AAC7B,aAAW,CAACC,UAAS,mBAAmB,KAAK,mBAAmB;AAC9D,eAAW,CAAC,OAAO,OAAO,KAAK,qBAAqB;AAClD,YAAM,wBAAwB,eAAe,IAAI,KAAK;AACtD,UAAI,uBAAuB;AACzB,uBAAe,IAAI,OAAO,sBAAsB,OAAO,OAAO,CAAC;AAAA,MACjE,OAAO;AACL,uBAAe,IAAI,OAAO,OAAO;AAAA,MACnC;AAAA,IACF;AACA,aAAS,KAAKA,QAAO;AAAA,EACvB;AACA,QAAM,UAAmB,CAAC,OAAO,WAAW,QAAQ;AAClD,eAAWA,YAAW,UAAU;AAC9B,MAAAA,SAAQ,OAAO,WAAW,GAAG;AAAA,IAC/B;AAAA,EACF;AACA,SAAO,CAAC,SAAS,cAAc;AACjC;;;AR5FA,IAAMC,UAAS,CAAC,QAAkB,CAAC,GAAG,IAAI,IAAI,GAAG,CAAC;AAQ3C,IAAM,YAAN,MAAgB;AAAA,EACrB,aAAiC,oBAAI,IAAI;AAAA,EACzC,YAAuD,CAAC;AAAA,EACxD;AAAA,EACA,gBAAwB;AAAA,EACxB,qBAAyD,CAAC;AAAA,EAC1D;AAAA,EACA;AAAA,EACA,uBAAiC;AAAA,EACjC,oBAA8B;AAAA,EAE9B,YACE,QACA,UAKI,CAAC,GACL;AACA,SAAK,uBAAuB,QAAQ;AACpC,SAAK,uBAAuB,QAAQ;AACpC,SAAK,oBAAoB,QAAQ;AACjC,QAAI,CAAC,QAAQ,SAAS;AACpB,WAAK,aAAa,IAAI,WAAW;AAAA,IACnC;AACA,QAAI,QAAQ;AACV,iBAAW,SAASA,QAAO,MAAM,GAAG;AAClC,aAAK,cAAc,KAAK;AAAA,MAC1B;AAAA,IACF;AAAA,EACF;AAAA,EAEA,cAAc,OAAsB;AAClC,UAAM,oBAAoB,KAAK,WAAW,IAAI,KAAK;AACnD,QAAI,mBAAmB;AACrB,aAAO;AAAA,IACT;AACA,UAAM,gBAAgB;AAAA,MACpB;AAAA,MACA,KAAK,uBACD,KAAK,uBACL,KAAK,aACL,CAAC,OAAO,KAAK,YAAY,aAAa,EAAE,IACxC;AAAA,MACJ,KAAK;AAAA,IACP;AACA,SAAK,WAAW,IAAI,OAAO,aAAa;AACxC,kBAAc,QAAQ,EAAE;AAAA,MACtB,CAAC,gBAAgB;AACf,uBAAe,GAAG,UAAU,CAACC,QAAe,QAAgB;AAC1D,eAAK,UAAU,QAAQ,CAAC,OAAO,GAAGA,QAAO,GAAG,CAAC;AAAA,QAC/C,CAAC;AAAA,MACH;AAAA,MACA,CAAC,eAAe;AACd,gBAAQ,KAAK,gCAAgC,KAAK;AAAA,MACpD;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,QAAQ;AACZ,UAAM,WAAW,CAAC;AAClB,eAAW,iBAAiB,KAAK,WAAW,OAAO,GAAG;AACpD,eAAS,KAAK,cAAc,MAAM,CAAC;AAAA,IACrC;AACA,SAAK,WAAW,MAAM;AACtB,WAAO,QAAQ,IAAI,QAAQ;AAAA,EAC7B;AAAA,EAEA,gBACE,OACA,SACA,SACA,QACiB;AACjB,UAAM,+BACJ,kCAAkC,OAAO;AAC3C,QAAI,6BAA6B,WAAW,GAAG;AAC7C;AAAA,IACF;AACA,UAAM,WAAW,KAAK,cAAc,KAAK;AACzC,UAAM,MAAM,SAAS,IAAI,4BAA4B;AACrD,QAAI,cAAmC,CAAC;AACxC,QAAI,GAAG,SAAS,CAAC,eAAsC;AACrD,UAAI,QAAQ,IAAI;AAAA,QACd;AAAA,QACA;AAAA,QACA,MAAM,KAAK,KAAK,WAAW,KAAK,CAAC;AAAA,MACnC;AACA,WAAK,YAAY,SAAS,KAAK;AAC/B,mBAAa,KAAK,KAAK;AACvB,cAAQ,OAAO,gBAAgB,QAAW,KAAK;AAAA,IACjD,CAAC;AACD,QAAI,QAAQ;AACV,UAAI,GAAG,QAAQ,MAAM;AACnB,eAAO,aAAa,KAAK;AACzB,sBAAc;AAAA,MAChB,CAAC;AAAA,IACH;AACA,WAAO;AAAA,EACT;AAAA,EAEA,iBACE,gBACA,SACA,QACY;AACZ,QAAI,eAAe,SAAS,GAAG;AAC7B,aAAO,MAAM;AAAA,MAAC;AAAA,IAChB;AACA,QAAI,CAAC,KAAK,sBAAsB;AAC9B,cAAQ,IAAI,mCAAmC,cAAc;AAAA,IAC/D;AACA,UAAM,OAAc,CAAC;AACrB,eAAW,CAAC,OAAO,OAAO,KAAK,gBAAgB;AAC7C,YAAM,MAAM,KAAK,gBAAgB,OAAO,SAAS,SAAS,MAAM;AAChE,UAAI,KAAK;AACP,aAAK,KAAK,GAAG;AAAA,MACf;AAAA,IACF;AACA,WAAO,MAAM,KAAK,QAAQ,CAAC,QAAQ,IAAI,MAAM,CAAC;AAAA,EAChD;AAAA,EAEA,kBAAkB,QAAiB;AACjC,iBAAa,KAAK,KAAK;AACvB,SAAK,QAAQ;AACb,SAAK,gBAAgB;AAErB,UAAM,CAAC,SAAS,cAAc,IAC5B,oBAAoB,KAAK,kBAAkB;AAC7C,SAAK,qBAAqB,CAAC;AAE3B,WAAO,KAAK,iBAAiB,gBAAgB,SAAS,MAAM;AAAA,EAC9D;AAAA,EAEA,YAAY,YAAoB;AAC9B,QAAI,KAAK,gBAAgB,YAAY;AACnC,WAAK,gBAAgB;AAAA,IACvB;AAEA,iBAAa,KAAK,KAAK;AACvB,SAAK,QAAQ;AAEb,QAAI,KAAK,kBAAkB,UAAU;AACnC,WAAK,QAAQ,WAAW,MAAM;AAC5B,aAAK,kBAAkB;AAAA,MACzB,GAAG,KAAK,aAAa;AAAA,IACvB;AAAA,EACF;AAAA,EAEA,UACE,SACA,QACA,SACA,YACA,QACA,UAAwE,CAAC,GAC7D;AACZ,QAAI,cAAc,QAAQ;AACxB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AACA,UAAM,CAAC,gBAAgB,cAAc,IACnC;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK;AAAA,IACP;AACF,SAAK,mBAAmB,KAAK,CAAC,gBAAgB,cAAc,CAAC;AAC7D,QAAI,YAAY;AACd,WAAK,YAAY,UAAU;AAC3B,aAAO,MAAM;AAAA,MAAC;AAAA,IAChB;AACA,WAAO,KAAK,kBAAkB,MAAM;AAAA,EACtC;AAAA,EAEA,MAAM,aACJ,IACA,QACA,YACgB;AAChB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,WAAK;AAAA,QACH,CAAC,EAAC,KAAK,CAAC,EAAE,EAAC,CAAC;AAAA,QACZ;AAAA,QACA,CAAC,UAAU;AACT,kBAAQ,KAAK;AAAA,QACf;AAAA,QACA;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA,EAEA,QAAQ,OAAwB,QAAkB;AAChD,UAAM,cAAc,EAAC,GAAG,OAAO,IAAI,aAAa,KAAK,EAAC;AACtD,eAAW,SAASD,QAAO,MAAM,GAAG;AAClC,YAAM,WAAW,KAAK,cAAc,KAAK;AACzC,eAAS,QAAQ,WAAW;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,SAAS,IAAwC;AAC/C,SAAK,UAAU,KAAK,EAAE;AAAA,EACxB;AAAA,EAEA,QAAQ,IAAwC;AAC9C,SAAK,WAAW;AAAA,MAAQ,CAAC,OAAc,QACrC,MAAM,GAAG,SAAS,CAAC,QAAgB,GAAG,KAAK,GAAG,CAAC;AAAA,IACjD;AAAA,EACF;AAAA,EACA,aAAa,IAAwC;AACnD,SAAK,WAAW;AAAA,MAAQ,CAAC,OAAc,QACrC,MAAM,GAAG,cAAc,CAAC,QAAgB,GAAG,KAAK,GAAG,CAAC;AAAA,IACtD;AAAA,EACF;AAAA,EACA,mBAAmD;AACjD,WAAO,MAAM,KAAK,KAAK,WAAW,QAAQ,CAAC,EACxC;AAAA,MACC,CAAC,CAAC,KAAK,KAAK,MACV,CAAC,KAAK,MAAM,MAAM;AAAA,IACtB,EACC,KAAK;AAAA,EACV;AACF;;;ASjPA,IAAM,eAAe,SAAU,GAAY,QAAe;AACxD,MAAI,IAAI,GACN,IAAI,EAAE,SAAS,GACf,GACA;AACF,MAAI,aAAa,SAAUE,IAAU,GAAU;AAC7C,WAAOA,GAAE,aAAa,EAAE;AAAA,EAC1B;AACA,SAAO,KAAK,GAAG;AACb,QAAK,IAAI,MAAO;AAChB,iBAAa,WAAW,EAAE,IAAI,MAAM;AACpC,QAAI,aAAa,GAAG;AAClB,UAAI,IAAI;AAAA,IACV,WAAW,aAAa,GAAG;AACzB,UAAI,IAAI;AAAA,IACV,OAAO;AACL,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO,CAAC;AACV;AAEA,IAAM,eAAe,SAAU,GAAY,QAAe;AACxD,QAAM,YAAY;AAClB,MAAI,IAAI,aAAa,GAAG,MAAM;AAC9B,MAAI,KAAK,GAAG;AAEV,QAAI,CAAC,WAAW;AACd,aAAO;AAAA,IACT;AAAA,EACF,OAAO;AAEL,QAAI,CAAC;AAAA,EACP;AACA,IAAE,OAAO,GAAG,GAAG,MAAM;AACrB,SAAO;AACT;AAEO,SAAS,QACd,UACA,WAAoB,OACX;AACT,MAAI,SAAkB,CAAC;AACvB,SAAO,CAAC,OAAc,WAAoB,QAA4B;AACpE,QAAI,UAAU;AACZ,aAAO,KAAK,KAAK;AAAA,IACnB,OAAO;AACL,mBAAa,QAAQ,KAAK;AAAA,IAC5B;AACA,aAAS,MAAM;AAAA,EACjB;AACF;",
  "names": ["event", "id", "Kind", "pubkey", "Kind", "filters", "onEvent", "unique", "relay", "a"]
}
